*** squidclamav/main.c	Mon Aug 28 10:41:05 2006
--- main.c.indent	Thu Feb  1 11:23:06 2007
***************
*** 100,106 ****
  struct IN_BUFF in_buff;
  
  
! void
  sigalarm (int sig)
  {
    logit(log_file, "LOG Timeout waiting for clamd response\n");
--- 100,106 ----
  struct IN_BUFF in_buff;
  
  
!   void
  sigalarm (int sig)
  {
    logit(log_file, "LOG Timeout waiting for clamd response\n");
***************
*** 108,114 ****
  }
  
  /* Get download as stream  */
! size_t
  write_data (void *ptr, size_t data_size, size_t nmemb, void *stream)
  {
    int ret;
--- 108,114 ----
  }
  
  /* Get download as stream  */
!   size_t
  write_data (void *ptr, size_t data_size, size_t nmemb, void *stream)
  {
    int ret;
***************
*** 120,158 ****
      logit(log_file, "DEBUG Sending data to clamd\n");
    ret = write (wsockd, ptr, msize);
    if (ret <= 0)
!     {
! 	    if (debug != 0)
! 	      logit(log_file, "DEBUG Can't write to clamd socket.\n");
! 	    close (wsockd);
!     }
    else
!     {
!       if (debug != 0)
! 	logit(log_file, "DEBUG Write %d bytes on %d to socket\n", ret, msize);
!     }
  
    return msize;
  }
  
  /* 
!     Under normal conditions, SquidClamav will never abort (you don't
!     want your Squid to suddenly die if you've put an invalid
!     regex into your config file, or renamed the config file!  
!     Under these abnormal conditions, squidclamav will run in bridge_mode 
!     where stdin is echoed to stdout!
! 
!     If you've entered an invalid regex expression that regcomp()
!     doesn't like, or perhaps an invalid network number, check it 
!     out in the ERROR_LOG.
!     
!     It should never ever abort under normal circumstances - even
!     if it can't allocate memory (which shouldn't happen, and Squid 
!     would be running like a dog under low memory conditions anyway) 
!     bridge_mode will be set and it will keep running :-)
!     
  */
  
! int
  main (int argc, char **argv)
  {
    char buff[MAX_BUFF]; /* Squid entry */
--- 120,158 ----
      logit(log_file, "DEBUG Sending data to clamd\n");
    ret = write (wsockd, ptr, msize);
    if (ret <= 0)
!   {
!     if (debug != 0)
!       logit(log_file, "DEBUG Can't write to clamd socket.\n");
!     close (wsockd);
!   }
    else
!   {
!     if (debug != 0)
!       logit(log_file, "DEBUG Write %d bytes on %d to socket\n", ret, msize);
!   }
  
    return msize;
  }
  
  /* 
!    Under normal conditions, SquidClamav will never abort (you don't
!    want your Squid to suddenly die if you've put an invalid
!    regex into your config file, or renamed the config file!  
!    Under these abnormal conditions, squidclamav will run in bridge_mode 
!    where stdin is echoed to stdout!
! 
!    If you've entered an invalid regex expression that regcomp()
!    doesn't like, or perhaps an invalid network number, check it 
!    out in the ERROR_LOG.
! 
!    It should never ever abort under normal circumstances - even
!    if it can't allocate memory (which shouldn't happen, and Squid 
!    would be running like a dog under low memory conditions anyway) 
!    bridge_mode will be set and it will keep running :-)
! 
  */
  
!   int
  main (int argc, char **argv)
  {
    char buff[MAX_BUFF]; /* Squid entry */
***************
*** 187,231 ****
  
    /* go into interactive mode if we're run as root */
    if ((int) getuid () == 0)
!     {
!       interactive = 1;
!       fprintf (stderr,
! 	       "SquidClamav running as UID 0: writing logs to stderr\n");
!     }
  
    /* check for alternate config file given as first argument */
    if (argc == 2) {
! 	alternate_config = (char *)malloc(sizeof(char) * (strlen(argv[1]) +1));
! 	if(alternate_config == NULL) {
! 		fprintf(stderr, "unable to allocate memory in main()\n");
! 		exit(EXIT_FAILURE);
! 	}
!         alternate_config = argv[1];
  
    }
  
    if (argc > 2)
!     {
!       fprintf (stderr, "squidclamav: invalid arguments\n");
!       fprintf (stderr, "Usage: %s [alternate-squidclamav.conf-file]\n",
! 	       argv[0]);
!       usleep (1000000);		/* don't do DoS */
!       exit(0);
!     }
  
    /* make stdout line buffered */
    if (setvbuf (stdout, NULL, _IOLBF, 0) != 0)
!     {
!       fprintf (stderr, "stdout not line buffered exiting\n");
!       usleep (1000000);		/* don't do DoS */
!       exit (2);
!     }
  
    bridge_mode = 0;
  
!  /*********************
!    read config files
!   ********************/
    load_patterns ();
    regexv = regcomp_pattern();
  
--- 187,231 ----
  
    /* go into interactive mode if we're run as root */
    if ((int) getuid () == 0)
!   {
!     interactive = 1;
!     fprintf (stderr,
! 	"SquidClamav running as UID 0: writing logs to stderr\n");
!   }
  
    /* check for alternate config file given as first argument */
    if (argc == 2) {
!     alternate_config = (char *)malloc(sizeof(char) * (strlen(argv[1]) +1));
!     if(alternate_config == NULL) {
!       fprintf(stderr, "unable to allocate memory in main()\n");
!       exit(EXIT_FAILURE);
!     }
!     alternate_config = argv[1];
  
    }
  
    if (argc > 2)
!   {
!     fprintf (stderr, "squidclamav: invalid arguments\n");
!     fprintf (stderr, "Usage: %s [alternate-squidclamav.conf-file]\n",
! 	argv[0]);
!     usleep (1000000);		/* don't do DoS */
!     exit(0);
!   }
  
    /* make stdout line buffered */
    if (setvbuf (stdout, NULL, _IOLBF, 0) != 0)
!   {
!     fprintf (stderr, "stdout not line buffered exiting\n");
!     usleep (1000000);		/* don't do DoS */
!     exit (2);
!   }
  
    bridge_mode = 0;
  
!   /*********************
!     read config files
!    ********************/
    load_patterns ();
    regexv = regcomp_pattern();
  
***************
*** 239,608 ****
  
    if (!bridge_mode) {
  
!       /* curl init */
!       curl_global_init (CURL_GLOBAL_ALL);
!       /* get an easy handle */
!       if ((eh = curl_easy_init ()) == NULL)
! 	{
! 	  logit(log_file, "PANIC Curl easy initialization failed\n");
! 	  curl_global_cleanup ();
! 	  bridge_mode = 1;
! 	  logit(log_file, "PANIC Invalid condition - continuing in BRIDGE mode\n");
! 	}
!       else
! 	{
! 	  /* set the curl output to temporary file */
! 	  curl_easy_setopt (eh, CURLOPT_WRITEFUNCTION, &write_data);
! 	  /* set the error buffer */
! 	  curl_easy_setopt (eh, CURLOPT_ERRORBUFFER, err);
! 	  /* set the libcurl transfer timeout */
! 	  curl_easy_setopt (eh, CURLOPT_TIMEOUT, timeout);
! 	  /* do not install signal  handlers in thread context */
! 	  curl_easy_setopt (eh, CURLOPT_NOSIGNAL, 1);
! 	  /* Force HTTP 1.0 version */
! 	  curl_easy_setopt (eh, CURL_HTTP_VERSION_1_0, TRUE);
! 	  /* Do not fail on errors: use to prevent breaked download when
! 	   * size of the download is upper than clamd scan limit
! 	   * Drop error on debug mode  */
! 	  if (debug != 0) {
! 		  curl_easy_setopt (eh, CURLOPT_FAILONERROR, TRUE);
! 	  } else {
! 		  curl_easy_setopt (eh, CURLOPT_FAILONERROR, FALSE);
! 	  }
! 	  /* follow location (303 MOVED) */
! 	  curl_easy_setopt (eh, CURLOPT_FOLLOWLOCATION, TRUE);
! 	  /* only follow 3 redirects */
! 	  curl_easy_setopt (eh, CURLOPT_MAXREDIRS, 3);
! 	}
      }
  
    while (fgets (buff, MAX_BUFF, stdin) != NULL)
      {
  
! 	/* chop buff */
! 	buff[strlen(buff) -1] = '\0';
  
! 	/* Start timing */
! 	if (statit)
! 		ftime(&g_start);
  
! 	/* chaining with SquidGuard - before bridge mode or not*/
! 	if (squidguard != NULL) {
! 		memset(command, 0, sizeof(command));
! 		strcpy(command, "echo \"");
! 		strcat(command, escape_quote(buff));
! 		strcat(command, "\" | ");
! 		strcat(command, squidguard);
! 		if (debug != 0)
! 		    logit(log_file, "DEBUG Chained program system command execution: %s\n", command);
! 		chain_pipe = popen (command, "r");
! 		if ( (!chain_pipe) && debug) {
! 		    logit(log_file, "ERROR Can't open pipe to %s\n", squidguard);
! 		    /* go ahead */
! 		} else {
! 			/* the chained redirector must return empty line if ok
! 			   or the redirection url */
! 			fgets(chain_ret, MAX_BUFF, chain_pipe);
! 			if (strlen(chain_ret) > 1) {
! 				if (debug != 0)
! 					logit(log_file, "DEBUG Received from chained program: %s", chain_ret);
! 				/* Close chain_pipe, checking for errors */
! 				if (pclose (chain_pipe) != 0)
! 					logit(log_file, "ERROR Could not run %s or other error.\n", squidguard);
! 				if (statit)
! 					timeit(g_start, "Chained program call");
! 				/* return the redirection url to squid */
! 				fprintf (stdout, "%s", chain_ret);
! 				/* do not go further */
! 				continue;
! 			}
! 			/* Close chain_pipe, checking for errors */
! 			if (pclose (chain_pipe) != 0)
! 				logit(log_file, "ERROR Could not run %s or other error.\n", squidguard);
! 		}
! 		if (statit)
! 			timeit(g_start, "Chained program call");
! 		if (debug != 0)
! 		  logit(log_file, "DEBUG Going to antivir scan part\n");
! 	}
  
!       /* if configs are completely invalid or some other
!          exception occurs where we want the redirector to
!          continue operation (so that Squid still works!),
!          we simply echo stdin to stdout - i.e. "bridge mode" :-) */
!       if (bridge_mode)
! 	{
  	  fprintf (stdout, "\n");
  	  continue;
  	}
! 
!       /* separate the four fields
!          from the single input line 
!          of stdin */
!       buff_status = load_in_buff (buff, &in_buff);
! 
!       /* if four fields couldn't be separated, or the
!          converted values aren't appropriate, then
!          just echo back the line from stdin */
! 
!       if (buff_status == 1)
  	{
  	  fprintf (stdout, "\n");
  	  continue;
  	}
  
!       /* now we can compare the URL to virus scan rules */
!       found = pattern_compare (regexv, in_buff.url);
!       /* -1 mean abort match => No antivir check */
!       /* if there's a regex and no content type pattern search and the regex
!          pattern is not found => No antivir check */
!       if ((found == -1)
! 	  || ((check_content_type == 0) && (has_regex == 1) && (found == 0)))
  	{
! 
! 	  if (debug != 0)
! 	    logit(log_file, "DEBUG No antivir check for url:%s\n", in_buff.url);
  	    if (statit)
! 		timeit(g_start, "Total");
! 
! 	  /* no replacement for the URL was found */
! 	  fprintf (stdout, "\n");
! 	  continue;
! 
! 	} else {
! 
! 	  /* set no proxy */
! 	  curl_easy_setopt (eh, CURLOPT_PROXY, "");
! 	  /* set the url */
! 	  curl_easy_setopt (eh, CURLOPT_URL, in_buff.url);
! 	  /* only get the header to check size and content type */
! 	  curl_easy_setopt (eh, CURLOPT_NOBODY, TRUE);
! 
! 	  /* download the header */
!          if (debug != 0)
! 		logit(log_file, "DEBUG Getting header for url %s\n", in_buff.url);
! 	  if (curl_easy_perform (eh) != 0)
! 	    {
! 	        if (force == 0) {
! 		      /* no header so just go back to squid */
! 		      if (debug != 0)
! 		        logit(log_file, "DEBUG No/bad header from url %s\n", in_buff.url);
! 			if (statit)
! 				timeit(g_start, "Total");
! 		      fprintf (stdout, "\n");
! 		      continue;
! 		} else {
! 		      if (debug != 0)
! 	                logit(log_file, "DEBUG Force scanning ... No/bad header from url %s\n", in_buff.url);
! 		    force_scan = 1;
! 		}
! 	    }
! 	  if (force_scan == 0) {
! 	  /* get the Content Length from the header */
! 	  if (curl_easy_getinfo (eh, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &usize)
! 	      != CURLE_OK)
! 	    {
! 		      /* not ok --> squid should handle this */
! 		      logit(log_file, "ERROR No content length from url %s\n", in_buff.url);
! 		      if (statit)
! 				timeit(g_start, "Total");
! 		      fprintf (stdout, "\n");
! 		      continue;
! 	    }
  	  if (debug != 0)
! 	    logit(log_file, "DEBUG File size is %'.2f\n", usize);
! 
! 	  /* get the CONTENT_TYPE out of the header */
! 	  if (check_content_type == 1)
! 	    {
! 	      if (curl_easy_getinfo (eh, CURLINFO_CONTENT_TYPE, &content_type) != CURLE_OK)
! 		{
! 		  /* not ok --> squid should handle this */
! 		  logit(log_file, "ERROR No content type from url %s\n",
! 		       in_buff.url);
! 		  if (statit)
! 			timeit(g_start, "Total");
! 		  fprintf (stdout, "\n");
! 		  continue;
! 	      }
! 	      if (debug != 0)
! 		logit(log_file, "DEBUG Content type is %s\n", content_type);
! 	      if ((content_type == NULL) || (pattern_compare(regexv, content_type) == 0))
! 		{
! 
! 		  if (debug != 0)
! 		    logit(log_file, "DEBUG No antivir check for content-type: %s\n", content_type);
! 			if (content_type != NULL)
! 				memset(content_type, 0, sizeof(content_type));
! 		    if (statit)
! 			timeit(g_start, "Total");
! 		  /* no replacement for the URL was found */
! 		  fprintf (stdout, "\n");
! 		  continue;
! 		}
! 	        if (debug != 0)
! 			logit(log_file, "DEBUG Content type is %s will be scanned\n", content_type);
! 		if (content_type != NULL)
! 			memset(content_type, 0, sizeof(content_type));
! 	    }
! 	}
  
! 	  /* Start timing */
! 	  if (statit)
! 		  ftime(&cs_start);
! 	  /***** Open a socket to Clamd daemon *****/
! 	  if ((sockd = dconnect ()) < 0)
! 	    {
! 	      logit(log_file, "ERROR Can't connect to Clamd daemon\n");
! 	      fprintf (stdout, "\n");
! 	      continue;
! 	    }
  	  if (debug != 0)
! 	    logit(log_file, "DEBUG Sending STREAM to clamd.\n");
  
! 	  if (write (sockd, "STREAM", 6) <= 0)
! 	    {
! 	      logit(log_file, "ERROR Can't write to Clamd socket.\n");
! 	      fprintf (stdout, "\n");
! 	      continue;
! 	    }
! 
! 	  while (loopw) {
! 	      char lbuff[1024];
! 
! 	      read (sockd, lbuff, sizeof (lbuff));
! 	      if ((pt = strstr (lbuff, "PORT")))
! 		{
! 		  pt += 5;
! 		  sscanf (pt, "%d", &port);
! 		  break;
! 		}
! 	      loopw--;
! 	    }
! 	  if (!loopw)
! 	    {
! 	      logit(log_file, "ERROR Clamd daemon not ready for stream scanning.\n");
! 	      fprintf (stdout, "\n");
! 	      continue;
! 	    }
! 	  if (debug != 0)
! 	    logit(log_file, "DEBUG Received port %d from clamd.\n", port);
  
! 	  /* connect to clamd given port */
! 	  if ((wsockd = socket (AF_INET, SOCK_STREAM, 0)) < 0)
! 	    {
! 	      logit(log_file, "ERROR Can't create the Clamd socket.\n");
! 	      fprintf (stdout, "\n");
! 	      continue;
! 	    }
! 
! 	  server.sin_family = AF_INET;
! 	  server.sin_port = htons (port);
! 
! 	  peer_size = sizeof (peer);
! 	  if (getpeername (sockd, (struct sockaddr *) &peer, &peer_size) < 0)
! 	    {
! 	      logit(log_file, "ERROR Can't get socket peer name.\n");
! 	      fprintf (stdout, "\n");
! 	      continue;
! 	    }
! 	  switch (peer.sin_family)
! 	    {
! 	    case AF_UNIX:
! 	      server.sin_addr.s_addr = inet_addr ("127.0.0.1");
! 	      break;
! 	    case AF_INET:
! 	      server.sin_addr.s_addr = peer.sin_addr.s_addr;
! 	      break;
! 	    default:
! 	      logit(log_file, "ERROR Unexpected socket type: %d.\n",
! 		   peer.sin_family);
! 	      continue;
! 	    }
  
! 	  if (debug != 0)
! 	    logit(log_file, "DEBUG Trying to connect to clamd [port: %d].\n", port);
  
! 	  if (connect
! 	      (wsockd, (struct sockaddr *) &server,
! 	       sizeof (struct sockaddr_in)) < 0)
! 	    {
! 	      close (wsockd);
! 	      logit(log_file, "ERROR Can't connect to clamd [port: %d].\n", port);
! 	      fprintf (stdout, "\n");
! 	      continue;
! 	    }
! 
! 	  /***** now get the body content *****/
! 
! 	  /* set proxy */
! 	  if (strcmp(proxy,"none") != 0) {
! 		  curl_easy_setopt (eh, CURLOPT_PROXY, proxy);
! 	  }
! 	  /* download body */
! 	  curl_easy_setopt (eh, CURLOPT_NOBODY, FALSE);
! 	  curl_easy_setopt (eh, CURLOPT_HTTPGET, TRUE);
! 	  if (curl_easy_perform (eh) != 0)
! 	    {
! 	      logit(log_file, "ERROR fail downloading url %s\n", in_buff.url);
! 	      logit(log_file, "ERROR CURLOPT_ERRORBUFFER: %s\n", err);
! 	      fprintf (stdout, "\n");
! 	      close (wsockd);
! 	      close (sockd);
! 	      if (debug != 0)
! 	        logit(log_file, "DEBUG Connection to clamd on port: %d closed.\n", port);
! 		if (statit)
! 			timeit(g_start, "Total");
! 	      continue;
! 	    }
  
! 	  close (wsockd);
! 	  if (debug != 0)
! 	    logit(log_file, "DEBUG Connection to clamd on port: %d closed.\n", port);
! 	  if (debug != 0)
! 	    logit(log_file, "DEBUG Reading clamd scan result.\n");
! 	  memset(cbuff, 0, sizeof(cbuff));
! 	  memset(urlredir, 0, sizeof(urlredir));
! 	  while ((nbread = read (sockd, cbuff, sizeof (cbuff))) > 0)
! 	    {
! 	      if (debug != 0)
! 		logit(log_file, "DEBUG received from Clamd: %s", cbuff);
! 	      if (strstr (cbuff, "FOUND\n"))
! 		{
! 		  sprintf (urlredir, "%s?url=%s&source=%s&user=%s&virus=%s",
! 			redirect_url,in_buff.url,in_buff.src_address,in_buff.ident,cbuff);
! 		  logit(log_file, "LOG Redirecting URL to: %s\n", urlredir);
! 		  replace (urlredir, " ", "+");
! 		  strcpy (in_buff.url, urlredir);
! 		}
! 	        memset(cbuff, 0, sizeof(cbuff));
! 	        memset(cbuff, 0, sizeof(urlredir));
! 	    }
! 	  close (sockd);
! 	  if (debug != 0)
! 	    logit(log_file, "DEBUG End reading clamd scan result.\n");
! 	  if (statit)
! 		timeit(cs_start, "Virus Scanning");
  
! 	  if (strlen (urlredir) > 0)
! 	    {
! 	      if (debug != 0)
! 		logit(log_file, "DEBUG Virus found send redirection to Squid.\n");
! 	      fprintf (stdout, "%s %s %s %s\n", in_buff.url,
! 		       in_buff.src_address, in_buff.ident, in_buff.method);
! 	    }
! 	  else
! 	    {
! 	      if (debug != 0)
! 		logit(log_file, "DEBUG No virus detected for URL: %s.\n",
! 		     in_buff.url);
! 	      fprintf (stdout, "\n");
! 	    }
! 	}
  	if (statit)
! 		timeit(g_start, "Total");
  
      }
  
    /* cleanup */
    curl_global_cleanup ();
--- 239,608 ----
  
    if (!bridge_mode) {
  
!     /* curl init */
!     curl_global_init (CURL_GLOBAL_ALL);
!     /* get an easy handle */
!     if ((eh = curl_easy_init ()) == NULL)
!     {
!       logit(log_file, "PANIC Curl easy initialization failed\n");
!       curl_global_cleanup ();
!       bridge_mode = 1;
!       logit(log_file, "PANIC Invalid condition - continuing in BRIDGE mode\n");
!     }
!     else
!     {
!       /* set the curl output to temporary file */
!       curl_easy_setopt (eh, CURLOPT_WRITEFUNCTION, &write_data);
!       /* set the error buffer */
!       curl_easy_setopt (eh, CURLOPT_ERRORBUFFER, err);
!       /* set the libcurl transfer timeout */
!       curl_easy_setopt (eh, CURLOPT_TIMEOUT, timeout);
!       /* do not install signal  handlers in thread context */
!       curl_easy_setopt (eh, CURLOPT_NOSIGNAL, 1);
!       /* Force HTTP 1.0 version */
!       curl_easy_setopt (eh, CURL_HTTP_VERSION_1_0, TRUE);
!       /* Do not fail on errors: use to prevent breaked download when
!        * size of the download is upper than clamd scan limit
!        * Drop error on debug mode  */
!       if (debug != 0) {
! 	curl_easy_setopt (eh, CURLOPT_FAILONERROR, TRUE);
!       } else {
! 	curl_easy_setopt (eh, CURLOPT_FAILONERROR, FALSE);
!       }
!       /* follow location (303 MOVED) */
!       curl_easy_setopt (eh, CURLOPT_FOLLOWLOCATION, TRUE);
!       /* only follow 3 redirects */
!       curl_easy_setopt (eh, CURLOPT_MAXREDIRS, 3);
      }
+   }
  
    while (fgets (buff, MAX_BUFF, stdin) != NULL)
+   {
+ 
+     /* chop buff */
+     buff[strlen(buff) -1] = '\0';
+ 
+     /* Start timing */
+     if (statit)
+       ftime(&g_start);
+ 
+     /* chaining with SquidGuard - before bridge mode or not*/
+     if (squidguard != NULL) {
+       memset(command, 0, sizeof(command));
+       strcpy(command, "echo \"");
+       strcat(command, escape_quote(buff));
+       strcat(command, "\" | ");
+       strcat(command, squidguard);
+       if (debug != 0)
+ 	logit(log_file, "DEBUG Chained program system command execution: %s\n", command);
+       chain_pipe = popen (command, "r");
+       if ( (!chain_pipe) && debug) {
+ 	logit(log_file, "ERROR Can't open pipe to %s\n", squidguard);
+ 	/* go ahead */
+       } else {
+ 	/* the chained redirector must return empty line if ok
+ 	   or the redirection url */
+ 	fgets(chain_ret, MAX_BUFF, chain_pipe);
+ 	if (strlen(chain_ret) > 1) {
+ 	  if (debug != 0)
+ 	    logit(log_file, "DEBUG Received from chained program: %s", chain_ret);
+ 	  /* Close chain_pipe, checking for errors */
+ 	  if (pclose (chain_pipe) != 0)
+ 	    logit(log_file, "ERROR Could not run %s or other error.\n", squidguard);
+ 	  if (statit)
+ 	    timeit(g_start, "Chained program call");
+ 	  /* return the redirection url to squid */
+ 	  fprintf (stdout, "%s", chain_ret);
+ 	  /* do not go further */
+ 	  continue;
+ 	}
+ 	/* Close chain_pipe, checking for errors */
+ 	if (pclose (chain_pipe) != 0)
+ 	  logit(log_file, "ERROR Could not run %s or other error.\n", squidguard);
+       }
+       if (statit)
+ 	timeit(g_start, "Chained program call");
+       if (debug != 0)
+ 	logit(log_file, "DEBUG Going to antivir scan part\n");
+     }
+ 
+     /* if configs are completely invalid or some other
+        exception occurs where we want the redirector to
+        continue operation (so that Squid still works!),
+        we simply echo stdin to stdout - i.e. "bridge mode" :-) */
+     if (bridge_mode)
      {
+       fprintf (stdout, "\n");
+       continue;
+     }
  
!     /* separate the four fields
!        from the single input line 
!        of stdin */
!     buff_status = load_in_buff (buff, &in_buff);
! 
!     /* if four fields couldn't be separated, or the
!        converted values aren't appropriate, then
!        just echo back the line from stdin */
  
!     if (buff_status == 1)
!     {
!       fprintf (stdout, "\n");
!       continue;
!     }
  
!     /* now we can compare the URL to virus scan rules */
!     found = pattern_compare (regexv, in_buff.url);
!     /* -1 mean abort match => No antivir check */
!     /* if there's a regex and no content type pattern search and the regex
!        pattern is not found => No antivir check */
!     if ((found == -1)
! 	|| ((check_content_type == 0) && (has_regex == 1) && (found == 0)))
!     {
  
!       if (debug != 0)
! 	logit(log_file, "DEBUG No antivir check for url:%s\n", in_buff.url);
!       if (statit)
! 	timeit(g_start, "Total");
! 
!       /* no replacement for the URL was found */
!       fprintf (stdout, "\n");
!       continue;
! 
!     } else {
! 
!       /* set no proxy */
!       curl_easy_setopt (eh, CURLOPT_PROXY, "");
!       /* set the url */
!       curl_easy_setopt (eh, CURLOPT_URL, in_buff.url);
!       /* only get the header to check size and content type */
!       curl_easy_setopt (eh, CURLOPT_NOBODY, TRUE);
! 
!       /* download the header */
!       if (debug != 0)
! 	logit(log_file, "DEBUG Getting header for url %s\n", in_buff.url);
!       if (curl_easy_perform (eh) != 0)
!       {
! 	if (force == 0) {
! 	  /* no header so just go back to squid */
! 	  if (debug != 0)
! 	    logit(log_file, "DEBUG No/bad header from url %s\n", in_buff.url);
! 	  if (statit)
! 	    timeit(g_start, "Total");
  	  fprintf (stdout, "\n");
  	  continue;
+ 	} else {
+ 	  if (debug != 0)
+ 	    logit(log_file, "DEBUG Force scanning ... No/bad header from url %s\n", in_buff.url);
+ 	  force_scan = 1;
  	}
!       }
!       if (force_scan == 0) {
! 	/* get the Content Length from the header */
! 	if (curl_easy_getinfo (eh, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &usize)
! 	    != CURLE_OK)
  	{
+ 	  /* not ok --> squid should handle this */
+ 	  logit(log_file, "ERROR No content length from url %s\n", in_buff.url);
+ 	  if (statit)
+ 	    timeit(g_start, "Total");
  	  fprintf (stdout, "\n");
  	  continue;
  	}
+ 	if (debug != 0)
+ 	  logit(log_file, "DEBUG File size is %'.2f\n", usize);
  
! 	/* get the CONTENT_TYPE out of the header */
! 	if (check_content_type == 1)
  	{
! 	  if (curl_easy_getinfo (eh, CURLINFO_CONTENT_TYPE, &content_type) != CURLE_OK)
! 	  {
! 	    /* not ok --> squid should handle this */
! 	    logit(log_file, "ERROR No content type from url %s\n",
! 		in_buff.url);
  	    if (statit)
! 	      timeit(g_start, "Total");
! 	    fprintf (stdout, "\n");
! 	    continue;
! 	  }
  	  if (debug != 0)
! 	    logit(log_file, "DEBUG Content type is %s\n", content_type);
! 	  if ((content_type == NULL) || (pattern_compare(regexv, content_type) == 0))
! 	  {
  
! 	    if (debug != 0)
! 	      logit(log_file, "DEBUG No antivir check for content-type: %s\n", content_type);
! 	    if (content_type != NULL)
! 	      memset(content_type, 0, sizeof(content_type));
! 	    if (statit)
! 	      timeit(g_start, "Total");
! 	    /* no replacement for the URL was found */
! 	    fprintf (stdout, "\n");
! 	    continue;
! 	  }
  	  if (debug != 0)
! 	    logit(log_file, "DEBUG Content type is %s will be scanned\n", content_type);
! 	  if (content_type != NULL)
! 	    memset(content_type, 0, sizeof(content_type));
! 	}
!       }
! 
!       /* Start timing */
!       if (statit)
! 	ftime(&cs_start);
!       /***** Open a socket to Clamd daemon *****/
!       if ((sockd = dconnect ()) < 0)
!       {
! 	logit(log_file, "ERROR Can't connect to Clamd daemon\n");
! 	fprintf (stdout, "\n");
! 	continue;
!       }
!       if (debug != 0)
! 	logit(log_file, "DEBUG Sending STREAM to clamd.\n");
  
!       if (write (sockd, "STREAM", 6) <= 0)
!       {
! 	logit(log_file, "ERROR Can't write to Clamd socket.\n");
! 	fprintf (stdout, "\n");
! 	continue;
!       }
! 
!       while (loopw) {
! 	char lbuff[1024];
! 
! 	read (sockd, lbuff, sizeof (lbuff));
! 	if ((pt = strstr (lbuff, "PORT")))
! 	{
! 	  pt += 5;
! 	  sscanf (pt, "%d", &port);
! 	  break;
! 	}
! 	loopw--;
!       }
!       if (!loopw)
!       {
! 	logit(log_file, "ERROR Clamd daemon not ready for stream scanning.\n");
! 	fprintf (stdout, "\n");
! 	continue;
!       }
!       if (debug != 0)
! 	logit(log_file, "DEBUG Received port %d from clamd.\n", port);
  
!       /* connect to clamd given port */
!       if ((wsockd = socket (AF_INET, SOCK_STREAM, 0)) < 0)
!       {
! 	logit(log_file, "ERROR Can't create the Clamd socket.\n");
! 	fprintf (stdout, "\n");
! 	continue;
!       }
  
!       server.sin_family = AF_INET;
!       server.sin_port = htons (port);
  
!       peer_size = sizeof (peer);
!       if (getpeername (sockd, (struct sockaddr *) &peer, &peer_size) < 0)
!       {
! 	logit(log_file, "ERROR Can't get socket peer name.\n");
! 	fprintf (stdout, "\n");
! 	continue;
!       }
!       switch (peer.sin_family)
!       {
! 	case AF_UNIX:
! 	  server.sin_addr.s_addr = inet_addr ("127.0.0.1");
! 	  break;
! 	case AF_INET:
! 	  server.sin_addr.s_addr = peer.sin_addr.s_addr;
! 	  break;
! 	default:
! 	  logit(log_file, "ERROR Unexpected socket type: %d.\n",
! 	      peer.sin_family);
! 	  continue;
!       }
  
!       if (debug != 0)
! 	logit(log_file, "DEBUG Trying to connect to clamd [port: %d].\n", port);
  
!       if (connect
! 	  (wsockd, (struct sockaddr *) &server,
! 	   sizeof (struct sockaddr_in)) < 0)
!       {
! 	close (wsockd);
! 	logit(log_file, "ERROR Can't connect to clamd [port: %d].\n", port);
! 	fprintf (stdout, "\n");
! 	continue;
!       }
! 
!       /***** now get the body content *****/
! 
!       /* set proxy */
!       if (strcmp(proxy,"none") != 0) {
! 	curl_easy_setopt (eh, CURLOPT_PROXY, proxy);
!       }
!       /* download body */
!       curl_easy_setopt (eh, CURLOPT_NOBODY, FALSE);
!       curl_easy_setopt (eh, CURLOPT_HTTPGET, TRUE);
!       if (curl_easy_perform (eh) != 0)
!       {
! 	logit(log_file, "ERROR fail downloading url %s\n", in_buff.url);
! 	logit(log_file, "ERROR CURLOPT_ERRORBUFFER: %s\n", err);
! 	fprintf (stdout, "\n");
! 	close (wsockd);
! 	close (sockd);
! 	if (debug != 0)
! 	  logit(log_file, "DEBUG Connection to clamd on port: %d closed.\n", port);
  	if (statit)
! 	  timeit(g_start, "Total");
! 	continue;
!       }
  
+       close (wsockd);
+       if (debug != 0)
+ 	logit(log_file, "DEBUG Connection to clamd on port: %d closed.\n", port);
+       if (debug != 0)
+ 	logit(log_file, "DEBUG Reading clamd scan result.\n");
+       memset(cbuff, 0, sizeof(cbuff));
+       memset(urlredir, 0, sizeof(urlredir));
+       while ((nbread = read (sockd, cbuff, sizeof (cbuff))) > 0)
+       {
+ 	if (debug != 0)
+ 	  logit(log_file, "DEBUG received from Clamd: %s", cbuff);
+ 	if (strstr (cbuff, "FOUND\n"))
+ 	{
+ 	  sprintf (urlredir, "%s?url=%s&source=%s&user=%s&virus=%s",
+ 	      redirect_url,in_buff.url,in_buff.src_address,in_buff.ident,cbuff);
+ 	  logit(log_file, "LOG Redirecting URL to: %s\n", urlredir);
+ 	  replace (urlredir, " ", "+");
+ 	  strcpy (in_buff.url, urlredir);
+ 	}
+ 	memset(cbuff, 0, sizeof(cbuff));
+ 	memset(cbuff, 0, sizeof(urlredir));
+       }
+       close (sockd);
+       if (debug != 0)
+ 	logit(log_file, "DEBUG End reading clamd scan result.\n");
+       if (statit)
+ 	timeit(cs_start, "Virus Scanning");
+ 
+       if (strlen (urlredir) > 0)
+       {
+ 	if (debug != 0)
+ 	  logit(log_file, "DEBUG Virus found send redirection to Squid.\n");
+ 	fprintf (stdout, "%s %s %s %s\n", in_buff.url,
+ 	    in_buff.src_address, in_buff.ident, in_buff.method);
+       }
+       else
+       {
+ 	if (debug != 0)
+ 	  logit(log_file, "DEBUG No virus detected for URL: %s.\n",
+ 	      in_buff.url);
+ 	fprintf (stdout, "\n");
+       }
      }
+     if (statit)
+       timeit(g_start, "Total");
+ 
+   }
  
    /* cleanup */
    curl_global_cleanup ();
***************
*** 613,619 ****
    return 0;
  }
  
! void
  sighup ()
  {
    signal (SIGHUP, sighup);	/* reset signal */
--- 613,619 ----
    return 0;
  }
  
!   void
  sighup ()
  {
    signal (SIGHUP, sighup);	/* reset signal */
***************
*** 625,631 ****
    exit (0);
  }
  
! void
  sigterm ()
  {
    signal (SIGTERM, sigterm);	/* reset signal */
--- 625,631 ----
    exit (0);
  }
  
!   void
  sigterm ()
  {
    signal (SIGTERM, sigterm);	/* reset signal */
***************
*** 636,661 ****
    exit (0);
  }
  
! void free_global () {
!   if (log_file != NULL)
! 	  free (log_file);
!   if (proxy != NULL)
! 	  free (proxy);
!   if (clamd_port != NULL)
! 	  free (clamd_port);
!   if (clamd_ip != NULL)
! 	  free (clamd_ip);
!   if (clamd_local != NULL)
! 	  free (clamd_local);
!   if (redirect_url != NULL)
! 	  free (redirect_url);
!   if (squidguard != NULL)
! 	  free (squidguard);
!   if (alternate_config != NULL)
! 	  free (alternate_config);
! }
  
! int
  dconnect ()
  {
    struct sockaddr_un userver;
--- 636,661 ----
    exit (0);
  }
  
!   void free_global () {
!     if (log_file != NULL)
!       free (log_file);
!     if (proxy != NULL)
!       free (proxy);
!     if (clamd_port != NULL)
!       free (clamd_port);
!     if (clamd_ip != NULL)
!       free (clamd_ip);
!     if (clamd_local != NULL)
!       free (clamd_local);
!     if (redirect_url != NULL)
!       free (redirect_url);
!     if (squidguard != NULL)
!       free (squidguard);
!     if (alternate_config != NULL)
!       free (alternate_config);
!   }
  
!   int
  dconnect ()
  {
    struct sockaddr_un userver;
***************
*** 668,807 ****
    memset ((char *) &server, 0, sizeof (server));
  
    if (clamd_local != NULL)
      {
!       userver.sun_family = AF_UNIX;
!       strncpy (userver.sun_path, clamd_local, sizeof(userver.sun_path));
!       if ((asockd = socket (AF_UNIX, SOCK_STREAM, 0)) < 0)
! 	{
! 	  logit(log_file, "ERROR Can't bind local socket on %s.\n", clamd_local);
! 	  return -1;
! 	}
!       if (connect
! 	  (asockd, (struct sockaddr *) &userver,
! 	   sizeof (struct sockaddr_un)) < 0)
! 	{
! 	  close (asockd);
! 	  logit(log_file, "ERROR Can't connect to clamd on local socket %s.\n", clamd_local);
! 	  return -1;
! 	}
! 
      }
!   else
      {
!       server.sin_addr.s_addr = inet_addr (clamd_ip);
  
!       if ((asockd = socket (AF_INET, SOCK_STREAM, 0)) < 0)
! 	{
! 	  logit(log_file, "ERROR Can't create the socket.\n");
! 	  return -1;
! 	}
  
!       server.sin_family = AF_INET;
!       server.sin_port = htons (atoi (clamd_port));
  
!       if ((he = gethostbyname (clamd_ip)) == 0)
! 	{
! 	  close (asockd);
! 	  logit(log_file, "ERROR Can't lookup clamd hostname.\n");
! 	  return -1;
! 	}
!       server.sin_addr = *(struct in_addr *) he->h_addr_list[0];
  
!       if (connect
! 	  (asockd, (struct sockaddr *) &server,
! 	   sizeof (struct sockaddr_in)) < 0)
! 	{
! 	  close (asockd);
! 	  logit(log_file, "ERROR Can't connect to clamd on server:port %s:%s.\n", clamd_ip,clamd_port);
! 	  return -1;
! 	}
      }
    return asockd;
  }
  
! void
  replace (char string[], char *from, char *to)
  {
    char *start, *p1, *p2;
    for (start = string; *start != '\0'; start++)
      {
!       p1 = from;
!       p2 = start;
!       while (*p1 != '\0')
! 	{
! 	  if (*p1 != *p2)
! 	    break;
! 	  p1++;
! 	  p2++;
! 	}
!       if (*p1 == '\0')
! 	{
! 	  for (p1 = to; *p1 != '\0'; p1++)
! 	    *start++ = *p1;
! 	}
      }
  }
  
  void timeit (struct timeb start, char *level)
  {
! 	struct timeb stop;
! 	double elapsed = 0;
  
! 	/* Stop timing and compute elapsed time */
! 	ftime(&stop);
! 	elapsed=((double) stop.time + ((double) stop.millitm * 0.001)) - ((double) start.time + ((double) start.millitm * 0.001));
! 	/* show stat */
! 	logit(log_file, "STAT %s process time %7.3f second(s)\n", level, elapsed);
  }
  
  /* 
     function to compute new string length,
     allocate memory and finally copy string 
     - Returned value must be freed -
!  */
! static char *
  escape_quote (char *s)
  {
! 	char *newstring;
! 	char *idx1, *idx2;
! 	int nbquotes = 0;
! 	int len = 0;
! 
! 	if (!s)
! 		return NULL;
! 
! 	len = strlen (s);
! 
! 	/* First, count quotes in string */
! 	idx1 = s;
! 	while (*idx1) {
! 		if (*(idx1++) == '"')
! 			nbquotes++;
! 	}
! 	/* If there is no quote in the string, return it */
! 	if (!nbquotes)
! 		return (strdup (s));
! 
! 	/* Or else, allocate memory for the new string */
! 	newstring = (char *) malloc (sizeof (char) * (len + nbquotes + 1));
! 	if (newstring == NULL) {
! 		logit(log_file, "PANIC Unable to allocate memory in escape_quote()\n");
! 		return NULL;
! 	}
! 	/* And prepend a backslash before any quote found in string */
! 	idx1 = s;
! 	idx2 = newstring;
! 	while (*idx1) {
! 		if (*idx1 == '"') {
! 			*(idx2++) = '\\';
! 			*(idx2++) = '"';
! 		} else {
! 			*(idx2++) = *idx1;
! 		}
! 		idx1++;
! 	}
! 	/* Add null char */
! 	*idx2 = '\0';
  
! 	return newstring;
  }
--- 668,807 ----
    memset ((char *) &server, 0, sizeof (server));
  
    if (clamd_local != NULL)
+   {
+     userver.sun_family = AF_UNIX;
+     strncpy (userver.sun_path, clamd_local, sizeof(userver.sun_path));
+     if ((asockd = socket (AF_UNIX, SOCK_STREAM, 0)) < 0)
      {
!       logit(log_file, "ERROR Can't bind local socket on %s.\n", clamd_local);
!       return -1;
      }
!     if (connect
! 	(asockd, (struct sockaddr *) &userver,
! 	 sizeof (struct sockaddr_un)) < 0)
      {
!       close (asockd);
!       logit(log_file, "ERROR Can't connect to clamd on local socket %s.\n", clamd_local);
!       return -1;
!     }
  
!   }
!   else
!   {
!     server.sin_addr.s_addr = inet_addr (clamd_ip);
  
!     if ((asockd = socket (AF_INET, SOCK_STREAM, 0)) < 0)
!     {
!       logit(log_file, "ERROR Can't create the socket.\n");
!       return -1;
!     }
  
!     server.sin_family = AF_INET;
!     server.sin_port = htons (atoi (clamd_port));
  
!     if ((he = gethostbyname (clamd_ip)) == 0)
!     {
!       close (asockd);
!       logit(log_file, "ERROR Can't lookup clamd hostname.\n");
!       return -1;
!     }
!     server.sin_addr = *(struct in_addr *) he->h_addr_list[0];
! 
!     if (connect
! 	(asockd, (struct sockaddr *) &server,
! 	 sizeof (struct sockaddr_in)) < 0)
!     {
!       close (asockd);
!       logit(log_file, "ERROR Can't connect to clamd on server:port %s:%s.\n", clamd_ip,clamd_port);
!       return -1;
      }
+   }
    return asockd;
  }
  
!   void
  replace (char string[], char *from, char *to)
  {
    char *start, *p1, *p2;
    for (start = string; *start != '\0'; start++)
+   {
+     p1 = from;
+     p2 = start;
+     while (*p1 != '\0')
      {
!       if (*p1 != *p2)
! 	break;
!       p1++;
!       p2++;
!     }
!     if (*p1 == '\0')
!     {
!       for (p1 = to; *p1 != '\0'; p1++)
! 	*start++ = *p1;
      }
+   }
  }
  
  void timeit (struct timeb start, char *level)
  {
!   struct timeb stop;
!   double elapsed = 0;
  
!   /* Stop timing and compute elapsed time */
!   ftime(&stop);
!   elapsed=((double) stop.time + ((double) stop.millitm * 0.001)) - ((double) start.time + ((double) start.millitm * 0.001));
!   /* show stat */
!   logit(log_file, "STAT %s process time %7.3f second(s)\n", level, elapsed);
  }
  
  /* 
     function to compute new string length,
     allocate memory and finally copy string 
     - Returned value must be freed -
!    */
!   static char *
  escape_quote (char *s)
  {
!   char *newstring;
!   char *idx1, *idx2;
!   int nbquotes = 0;
!   int len = 0;
! 
!   if (!s)
!     return NULL;
! 
!   len = strlen (s);
! 
!   /* First, count quotes in string */
!   idx1 = s;
!   while (*idx1) {
!     if (*(idx1++) == '"')
!       nbquotes++;
!   }
!   /* If there is no quote in the string, return it */
!   if (!nbquotes)
!     return (strdup (s));
! 
!   /* Or else, allocate memory for the new string */
!   newstring = (char *) malloc (sizeof (char) * (len + nbquotes + 1));
!   if (newstring == NULL) {
!     logit(log_file, "PANIC Unable to allocate memory in escape_quote()\n");
!     return NULL;
!   }
!   /* And prepend a backslash before any quote found in string */
!   idx1 = s;
!   idx2 = newstring;
!   while (*idx1) {
!     if (*idx1 == '"') {
!       *(idx2++) = '\\';
!       *(idx2++) = '"';
!     } else {
!       *(idx2++) = *idx1;
!     }
!     idx1++;
!   }
!   /* Add null char */
!   *idx2 = '\0';
  
!   return newstring;
  }
