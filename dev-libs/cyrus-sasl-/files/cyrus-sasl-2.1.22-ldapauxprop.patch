diff -Narc cyrus-sasl-2.1.22/config.h.in /root/cyrus-sasl-2.1.22/config.h.in
*** cyrus-sasl-2.1.22/config.h.in	Thu May 18 21:38:02 2006
--- /root/cyrus-sasl-2.1.22/config.h.in	Tue Jun 26 12:35:44 2007
***************
*** 332,337 ****
--- 332,340 ----
  /* Where do we look for saslauthd's socket? */
  #undef PATH_SASLAUTHD_RUNDIR
  
+ /* auxprop mechs we can link staticly? */
+ #undef STATIC_LDAPAUXPROP
+ 
  /* Runtime plugin location */
  #undef PLUGINDIR
  
diff -Narc cyrus-sasl-2.1.22/configure.in /root/cyrus-sasl-2.1.22/configure.in
*** cyrus-sasl-2.1.22/configure.in	Tue Jun 26 12:45:20 2007
--- /root/cyrus-sasl-2.1.22/configure.in	Tue Jun 26 12:42:51 2007
***************
*** 914,919 ****
--- 914,967 ----
      AC_MSG_RESULT(disabled)
  fi
  
+ ########################################################################
+ # Simon tries to do autoconf for ldap (has a book now)
+ 
+ dnl LDAP
+ AC_ARG_WITH(ldapauxprop, [  --with-ldapauxprop=PATH         enable authentication from LDAP [no] ],
+   with_ldapauxprop=$withval,
+   with_ldapauxprop=no)
+ 
+ if test "$with_ldapauxprop" =  "yes"; then
+   for ldaploc in lib/ldap lib
+   do
+     if test -f ${prefix}/${ldaploc}/libldap.a; then
+       with_ldapauxprop="${prefix}"
+       break
+     elif test -f /usr/local/${ldaploc}/libldap.a; then
+       with_ldapauxprop="/usr/local"
+       break
+     elif test -f /usr/${ldaploc}/libldap.a; then
+       with_ldapauxprop="/usr"
+       break
+     fi
+   done
+ fi
+ 
+ case "$with_ldapauxprop" in
+     no) true;;
+     *)
+        if test -d ${with_ldapauxprop}/include/ldap; then
+          CPPFLAGS="${CPPFLAGS} -I${with_ldapauxprop}/include/ldap"
+          LDFLAGS="$LDFLAGS -L${with_ldapauxprop}/lib/ldap"
+      else
+          CPPFLAGS="${CPPFLAGS} -I${with_ldapauxprop}/include"
+          LDFLAGS="$LDFLAGS -L${with_ldapauxprop}/lib"
+        fi
+        AC_CHECK_LIB(ldap, ldap_open,[
+               SASL_MECHS="$SASL_MECHS libldapauxprop.la"
+             SASL_STATIC_OBJS="$SASL_STATIC_OBJS ../plugins/ldapauxprop.o"
+             AC_DEFINE([STATIC_LDAPAUXPROP],[],[auxprop mechs we can link staticly?])],
+             [AC_ERROR([LDAP libarary ldap and lber not found])],
+             [-llber -lssl -lcrypto]);;
+ esac
+ AC_SUBST(LIB_LDAP)
+ 
+ # simon finishes trying to do autoconf
+ ###############################################################################
+   
+ 
+ 
  AC_SUBST(SASL_MECHS)
  AC_SUBST(SASL_STATIC_SRCS)
  AC_SUBST(SASL_STATIC_OBJS)
diff -Narc cyrus-sasl-2.1.22/doc/options.html /root/cyrus-sasl-2.1.22/doc/options.html
*** cyrus-sasl-2.1.22/doc/options.html	Wed Feb 16 21:52:05 2005
--- /root/cyrus-sasl-2.1.22/doc/options.html	Tue Jun 26 12:32:20 2007
***************
*** 333,338 ****
--- 333,391 ----
  </p>
  
  <hr>
+ 
+ 
+ 
+ 
+ <h4>Ldap auxprop options</h4><br>
+ 
+ <p><b>important note:</b>The auxprop will crash (SEGV) if the ldap libraries
+    are compiled against cyrus sasl Version 1.(see code for details)<br>
+ 
+  <p>  The plugin uses the following options:-<br>
+ <br>
+ <p>
+   ldap_user: (username to login as)<br>
+   ldap_passwd: (password to use)<br>
+   ldap_hostnames: (comma separated host list)<br>
+   ldap_filter: (filter to get to users password)<br>
+   ldap_basedn: (basedn for the search)<br>
+   ldap_verbose: (if it exists will print information to syslog)<br>
+ 
+ <p>The filter used in the option ldap_filter is parsed
+  for 2 place holders %u and %r they are replaced with username
+  and realm required respectively.
+ <br>
+ <font color=red>DO NOT PUT "' quotes around the filter</font>
+ <br>
+ 
+ <br>
+ <p>
+    %u is the username the user logged in as<br>
+    %r is the realm which could be the kerbros realm, the FQDN of the
+      computer the sasl app is on or what ever is after the @ on a username.<br>
+ <br>
+ 
+ <pre>
+    ldap_filter: uid=%u
+    ldap_filter: uid=%s,domain=%r,o=SURF
+ </pre>
+ 
+ <br><p>
+    If something matches the filter the code
+   will try and retrieve all properties requested.
+   Usually  userPassword and cmusaslsecretMECHNAME where
+   MECHNAME is the name of a mechanism.
+ <p>
+ 
+   ldap_hostnames: Can understands url type input.
+ <pre>
+       e.g. ldap:ldap.surf.org.uk:344,ldaps:secureldap.surf.org.uk
+ </pre>
+ 
+ 
+ 
+ 
  Back to the <A href=index.html>index</a>
  
  </body>
diff -Narc cyrus-sasl-2.1.22/doc/options.html.orig /root/cyrus-sasl-2.1.22/doc/options.html.orig
*** cyrus-sasl-2.1.22/doc/options.html.orig	Thu Jan  1 01:00:00 1970
--- /root/cyrus-sasl-2.1.22/doc/options.html.orig	Wed Feb 16 21:52:05 2005
***************
*** 0 ****
--- 1,340 ----
+ <HTML><HEAD>
+ <title>Options for Cyrus SASL</title>
+ <!-- $Id: options.html,v 1.30 2005/02/16 20:52:05 shadow Exp $ -->
+ </HEAD>
+ <BODY>
+ <h1>Options for Cyrus SASL</h1>
+ 
+ <p>This document contains information on what options are used by the
+ Cyrus SASL library and bundled mechanisms.  The most commonly used
+ options (and those that are therefore most commonly misunderstood
+ are <b>pwcheck_method</b> and <b>auxprop_plugin</b>.  Please ensure
+ that you have configured these correctly if things don't seem to
+ be working right.  Additionally, <b>mech_list</b> can be an easy
+ way to limit what mechanisms a given application will use.</p>
+ 
+ <TABLE BORDER WIDTH=95%>
+ <TR><TH>Option</TH><TH>Used By</TH><TH>Description</TH><TH>Default</TH></TR>
+ <TR>
+ <TD>authdaemond_path</TD><TD>SASL Library</TD> 
+ <TD>Path to Courier-IMAP authdaemond's unix socket.
+ Only applicable when pwcheck_method is set to authdaemond.</TD><TD>/dev/null</TD>
+ </TR>
+ <TR>
+ <TD>auto_transition</TD><TD>SASL Library</TD> 
+ <TD>When set to 'yes' or 'noplain',
+ and when using an auxprop plugin, automatically transition
+ users to other mechs when they do a successful plaintext
+ authentication.  When set to 'noplain', only non-plaintext secrets 
+ will be written.  <I>Note that the only mechs (as currently
+ implemented) which don't use plaintext secrets are
+ OTP and SRP.</I></TD><TD>no</TD>
+ </TR>
+ <TR>
+ <TD>auxprop_plugin</TD><TD>Auxiliary Property Plugin</TD>
+ <TD>Name of auxiliary plugin to use, you may specify a space-separated
+ list of plugin names, and the plugins will be queried in order</TD>
+ <TD>(null) - querys all plugins</TD>
+ </TR>
+ <TR>
+ <TD>canon_user_plugin</TD><TD>SASL Library</TD>
+ <TD>Name of canon_user plugin to use</TD><TD>INTERNAL</TD>
+ </TR>
+ <TR>
+ <TD>keytab</TD><TD>GSSAPI</TD> <TD>Location of keytab
+ file</TD><TD><tt>/etc/krb5.keytab</tt> (system dependant)</TD>
+ </TR>
+ <TR>
+ <TD>ldapdb_uri</TD><TD>LDAPDB plugin</TD>
+ <TD>ldap server uri, you can specify a space-separated list of URIs - 
+ ldapi:// or ldaps://ldap1/ ldaps://ldap2/</TD>
+ <TD>none</TD>
+ </TR>
+ <TR>
+ <TD>ldapdb_id</TD><TD>LDAPDB plugin</TD>
+ <TD>ldap SASL authentication id</TD>
+ <TD>none</TD>
+ </TR>
+ <TR>
+ <TD>ldapdb_mech</TD><TD>LDAPDB plugin</TD>
+ <TD>ldap SASL mechanism for authentication</TD>
+ <TD>none</TD>
+ </TR>
+ <TR>
+ <TD>ldapdb_pw</TD><TD>LDAPDB plugin</TD>
+ <TD>ldap password for SASL authentication id</TD>
+ <TD>none</TD>
+ </TR>
+ <TR>
+ <TD>ldapdb_rc</TD><TD>LDAPDB plugin</TD>
+ <TD>The filename specified here will be put into the server's LDAPRC
+ environment variable, and libldap-specific config options may be set
+ in that ldaprc file.  The main purpose behind this option is to allow
+ a client TLS certificate to be configured, so that SASL/EXTERNAL may
+ be used between the SASL server and the LDAP server. This is the most
+ optimal way to use this plugin when the servers are on separate machines.</TD>
+ <TD>none</TD>
+ </TR>
+ <TR>
+ <TD>ldapdb_starttls</TD><TD>LDAPDB plugin</TD>
+ <TD>Use StartTLS.  This option may be set to 'try' or 'demand'.  
+ When set to "try" any failure in StartTLS is ignored. 
+ When set to "demand" then any failure aborts the connection.</TD>
+ <TD>none</TD>
+ </TR>
+ <TR>
+ <TD>log_level</TD><TD>SASL Library</TD>
+ <TD><b>Numeric</b> Logging Level (see <TT>SASL_LOG_*</TT> in <tt>sasl.h</tt>
+ for values and descriptions</TD>
+ <TD>1 (SASL_LOG_ERR)</TD>
+ </TR>
+ <TR>
+ <TD>mech_list</TD><TD>SASL Library</TD>
+ <TD>Whitespace separated list of mechanisms to allow (e.g. 'plain
+ otp').  Used to restrict the mechanisms to a subset of the installed
+ plugins.</TD><TD>(use all available plugins)</TD>
+ </TR>
+ <TR>
+ <TD>ntlm_server</TD><TD>NTLM (server)</TD>
+ <TD>Name of server (WinNT, Win2K, Samba, etc) to which authentication
+ will be proxied.</TD>
+ <TD>(null) - perform authentication internally</TD>
+ </TR>
+ <TR>
+ <TD>ntlm_v2</TD><TD>NTLM (client)</TD>
+ <TD>Send NTLMv2 responses to the server.</TD>
+ <TD>no (send NTLMv1)</TD>
+ </TR>
+ <TR>
+ <TD>opiekeys</TD><TD>OTP (with OPIE)</TD>
+ <TD>Location of the opiekeys file</TD><TD><tt>/etc/opiekeys</tt></TD>
+ </TR>
+ <TR>
+ <TD>otp_mda</TD><TD>OTP (w/o OPIE)</TD>
+ <TD>Message digest algorithm for one-time passwords, used by sasl_setpass
+ (possible values: 'md4', 'md5', 'sha1')</TD><TD><tt>md5</tt></TD>
+ </TR>
+ <TR>
+ <TD>plugin_list</TD><TD>SASL Library</TD>
+ <TD>Location of Plugin list (Unsupported)</TD><TD><i>none</i></TD>
+ </TR>
+ <TR>
+ <TD>pwcheck_method</TD><TD>SASL Library</TD>
+ <TD>Whitespace separated list of mechanisms used to verify passwords,
+ used by sasl_checkpass (possible values: 'auxprop', 'saslauthd',
+ 'pwcheck', 'authdaemond' [if compiled with <tt>--with-authdaemond</tt>])
+ and 'alwaystrue' [if compiled with <tt>--enable-alwaystrue</tt>])
+ </TD><TD>auxprop</TD>
+ </TR>
+ <TR>
+ <TD>reauth_timeout</TD><TD>DIGEST-MD5</TD>
+ <TD>Length in time (in minutes) that authentication info will be
+ cached for a fast reauth.  A value of 0 will disable reauth.</TD>
+ <TD>0</TD>
+ </TR>
+ <TR>
+ <TD>saslauthd_path</TD><TD>SASL Library</TD>
+ <TD>Path to saslauthd run directory (<b>including</b> the "/mux" named pipe)</TD>
+ <TD>system dependant (generally won't need to be changed)</TD>
+ </TR>
+ <TR>
+ <TD>sasldb_path</TD><TD>sasldb plugin</TD>
+ <TD>Path to sasldb file</TD><TD><tt>/etc/sasldb2</tt> (system dependant)</TD>
+ <TR>
+ <TD>sql_engine</TD><TD>SQL plugin</TD>
+ <TD>Name of SQL engine to use (possible values: 'mysql', 'pgsql', 'sqlite').</TD>
+ <TD><tt>mysql</tt></TD>
+ </TR>
+ <TR>
+ <TD>sql_hostnames</TD><TD>SQL plugin</TD>
+ <TD>Comma separated list of SQL servers (in host[:port] format).</TD>
+ <TD><i>none</i> (engine dependent)</TD>
+ </TR>
+ <TR>
+ <TD>sql_user</TD><TD>SQL plugin</TD>
+ <TD>Username to use for authentication to the SQL server.</TD>
+ <TD><i>none</i> (engine dependent)</TD>
+ </TR>
+ <TR>
+ <TD>sql_passwd</TD><TD>SQL plugin</TD>
+ <TD>Password to use for authentication to the SQL server.</TD>
+ <TD><i>none</i> (engine dependent)</TD>
+ </TR>
+ <TR>
+ <TD>sql_database</TD><TD>SQL plugin</TD>
+ <TD>Name of the database which contains the auxiliary properties.</TD>
+ <TD><i>none</i> (engine dependent)</TD>
+ </TR>
+ <TR>
+ <TD>sql_select</TD><TD>SQL plugin</TD>
+ <TD>SELECT statement to use for fetching properties.  This option is
+ <b>required</b> in order to use the SQL plugin.</TD>
+ <TD><i>none</i></TD>
+ </TR>
+ <TR>
+ <TD>sql_insert</TD><TD>SQL plugin</TD>
+ <TD>INSERT statement to use for creating properties for new users.</TD>
+ <TD><i>none</i></TD>
+ </TR>
+ <TR>
+ <TD>sql_update</TD><TD>SQL plugin</TD>
+ <TD>UPDATE statement to use for modifying properties.</TD>
+ <TD><i>none</i></TD>
+ </TR>
+ <TR>
+ <TD>sql_usessl</TD><TD>SQL plugin</TD>
+ <TD>When set to 'yes', 'on', '1' or 'true', a secure connection will
+ be made to the SQL server.</TD>
+ <TD><tt>no</tt></TD>
+ </TR>
+ <TR>
+ <TD>srp_mda</TD><TD>SRP</TD>
+ <TD>Message digest algorithm for SRP calculations
+ (possible values: 'md5', 'sha1', 'rmd160')</TD><TD><tt>sha1</tt></TD>
+ </TR>
+ <TR>
+ <TD>srvtab</TD><TD>KERBEROS_V4</TD>
+ <TD>Location of the srvtab file</TD><TD><tt>/etc/srvtab</tt> (system
+ dependant)</TD>
+ </TR>
+ </TABLE>
+ 
+ <h2>Notes on SQL auxprop options</h2>
+ 
+ <p>The <tt>sql_insert</tt> and <tt>sql_update</tt> options are
+ optional and are only needed if you wish to allow the SASL library
+ (e.g., saslpasswd2) and plugins (e.g., OTP) to write properties to the
+ SQL server.  If used, both statements MUST be provided so that
+ properties can be added, changed and deleted.
+ <font color=red>NOTE: The columns for writable properites MUST accept NULL values.</font>
+ 
+ <p>The SQL statements provided in the <tt>sql_select</tt>,
+ <tt>sql_insert</tt> and <tt>sql_update</tt> options can contain
+ arguments which will be substituted with the appropriate values.  The
+ valid arguments are:
+ 
+ <DL compact>
+ <DT><tt>%u</tt> <DD>Username whose properties are being fetched/stored.
+ 
+ <DT><tt>%p</tt> <DD>Name of the property being fetched/stored.  This could
+      technically be anything, but SASL authentication will try
+      userPassword and cmusaslsecretMECHNAME (where MECHNAME is the
+      name of a SASL mechanism).
+ 
+ <DT><tt>%r</tt> <DD>Realm to which the user belongs.  This could be the
+      kerberos realm, the FQDN of the computer the SASL application is
+      running on or whatever is after the @ on a username.  (read the
+      realm documentation).
+ 
+ <DT><tt>%v</tt> <DD>Value of the property being stored (INSERT or
+      UPDATE only!). This could technically be anything depending on
+      the property itself, but is generally a userPassword.
+ </DL>
+ 
+ <font color=red>NOTE: DO NOT put quotes around the entire SQL
+ statement, but each individual %u, %r and %v argument MUST be
+ quoted.</font>
+ 
+ 
+ <h3>Examples:</h3>
+ 
+ <pre>
+      <tt>sql_select: SELECT %p FROM user_table WHERE username = '%u' and realm = '%r'</tt>
+ </pre>
+ 
+      would send the following statement to SQL for user "bovik" and
+      the default realm for the machine "madoka.surf.org.uk":
+ 
+ <pre>
+      <tt>SELECT userPassword FROM user_table WHERE username = 'bovik' and
+      realm = 'madoka.surf.org.uk';</tt>
+ 
+ 
+ </pre>
+ 
+ <pre>
+      <tt>sql_insert: INSERT INTO user_table (username, realm, %p) VALUES ('%u', '%r', '%v')</tt>
+ 
+ </pre>
+ 
+    would generate the following statement to SQL for user "bovik" in
+    realm "madoka.surf.org.uk" with userPassword "wert":
+ 
+ <pre>
+      <tt>INSERT INTO user_table (username, realm, userPassword) VALUES
+      ('bovik', 'madoka.surf.org.uk', 'wert');</tt>
+ 
+ 
+ </pre>
+ 
+ <p>Note that all substitutions do not have to be used. For instance,
+ <pre>
+      <tt>SELECT password FROM auth WHERE username = '%u'</tt>
+ </pre>
+ is a valid value for <tt>sql_select</tt>.
+ 
+ <h2>Notes on LDAPDB auxprop options</h2>
+ 
+ <p>
+ </p>
+ 
+ <p>Unlike other LDAP-enabled plugins for other services that are common
+ on the web, this plugin does not require you to configure DN search
+ patterns to map usernames to LDAP DNs. This plugin requires SASL name
+ mapping to be configured on the target slapd. This approach keeps the
+ LDAP-specific configuration details in one place, the slapd.conf, and
+ makes the configuration of remote services much simpler.</p>
+ 
+ <p>This plugin is not for use with slapd itself. When OpenLDAP is
+ built with SASL support, slapd uses its own internal auxprop module.
+ By default, without configuring anything else, slapd will fail to load
+ the ldapdb module when it's present. This is as it should be. If you
+ don't like the "auxpropfunc: error -7" message that is sent to syslog
+ by slapd, you can stop it by creating /usr/lib/sasl2/slapd.conf with:
+ 
+     <pre>auxprop_plugin: slapd</pre>
+ 
+ which will force the SASL library to ignore all other auxprop modules.</p>
+ 
+ <h3>Examples:</h3>
+ 
+ <pre>
+ ldapdb_uri: ldap://ldap.example.com
+ ldapdb_id: root
+ ldapdb_pw: secret
+ ldapdb_mech: DIGEST-MD5
+ </pre>
+ 
+ <p>The LDAP server must be configured to map the SASL authcId "root" into a DN
+ that has proxy authorization privileges to every account that is allowed to
+ login to this server. (See the OpenLDAP Admin Guide section 10 for
+ details.)</p>
+ 
+ <pre>
+ ldapdb_uri: ldapi://
+ ldapdb_mech: EXTERNAL
+ </pre>
+ 
+ <p>This configuration assumes an LDAP server is on the same server that is
+ using SASL and the underlying OS is *NIX based (ldapi:// requires UNIX domain
+ sockets).  This is fast and secure, and needs no username or password to be
+ stored.  The slapd.conf will need to map these usernames to LDAP DNs:
+ 
+ <pre>
+ sasl-regexp uidNumber=(.*)\\+gidNumber=(.*),cn=peercred,cn=external,cn=auth
+     ldap:///dc=example,dc=com??sub?(&(uidNumber=$1)(gidNumber=$2))
+ </pre>
+ 
+ <pre>
+ sasl-regexp uid=(.*),cn=external,cn=auth
+     ldap:///dc=example,dc=com??sub?(uid=$1)
+ </pre>
+ 
+ </p>
+ 
+ <hr>
+ Back to the <A href=index.html>index</a>
+ 
+ </body>
+ </html>
+ 
diff -Narc cyrus-sasl-2.1.22/lib/staticopen.h /root/cyrus-sasl-2.1.22/lib/staticopen.h
*** cyrus-sasl-2.1.22/lib/staticopen.h	Wed Feb 16 21:52:09 2005
--- /root/cyrus-sasl-2.1.22/lib/staticopen.h	Tue Jun 26 12:40:09 2007
***************
*** 125,130 ****
--- 125,133 ----
  #ifdef STATIC_LDAPDB
  extern SPECIFIC_AUXPROP_PLUG_INIT_PROTO( ldapdb );
  #endif
+ #ifdef STATIC_LDAPAUXPROP
+ extern SPECIFIC_AUXPROP_PLUG_INIT_PROTO( ldapauxprop);
+ #endif
  
  _sasl_plug_rec _sasl_static_plugins[] = {
  #ifdef STATIC_ANONYMOUS
***************
*** 176,180 ****
--- 179,186 ----
  #ifdef STATIC_LDAPDB
      SPECIFIC_AUXPROP_PLUG_INIT( ldapdb, "LDAPDB" ),
  #endif
+ #ifdef STATIC_LDAPAUXPROP
+ 	SPECIFIC_AUXPROP_PLUG_INIT( ldapauxprop, "LDAPAUXPROP" ),
+ #endif
  	{ UNKNOWN, NULL, NULL }
  };
diff -Narc cyrus-sasl-2.1.22/lib/staticopen.h.orig /root/cyrus-sasl-2.1.22/lib/staticopen.h.orig
*** cyrus-sasl-2.1.22/lib/staticopen.h.orig	Thu Jan  1 01:00:00 1970
--- /root/cyrus-sasl-2.1.22/lib/staticopen.h.orig	Wed Feb 16 21:52:09 2005
***************
*** 0 ****
--- 1,180 ----
+ /* staticopen.h
+  * Rob Siemborski
+  * Howard Chu
+  * $Id: staticopen.h,v 1.8 2005/02/16 20:52:09 shadow Exp $
+  */
+ /* 
+  * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  *
+  * 1. Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer. 
+  *
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in
+  *    the documentation and/or other materials provided with the
+  *    distribution.
+  *
+  * 3. The name "Carnegie Mellon University" must not be used to
+  *    endorse or promote products derived from this software without
+  *    prior written permission. For permission or any other legal
+  *    details, please contact  
+  *      Office of Technology Transfer
+  *      Carnegie Mellon University
+  *      5000 Forbes Avenue
+  *      Pittsburgh, PA  15213-3890
+  *      (412) 268-4387, fax: (412) 268-7395
+  *      tech-transfer@andrew.cmu.edu
+  *
+  * 4. Redistributions of any form whatsoever must retain the following
+  *    acknowledgment:
+  *    "This product includes software developed by Computing Services
+  *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+  *
+  * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+  * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+  * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+  * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+  * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ typedef enum {
+ 	UNKNOWN = 0, SERVER = 1, CLIENT = 2, AUXPROP = 3, CANONUSER = 4
+ } _sasl_plug_type;
+ 
+ typedef struct {
+ 	_sasl_plug_type type;
+ 	char *name;
+ 	sasl_client_plug_init_t *plug;
+ } _sasl_plug_rec;
+ 
+ /* For static linking */
+ #define SPECIFIC_CLIENT_PLUG_INIT_PROTO( x ) \
+ sasl_client_plug_init_t x##_client_plug_init
+ 
+ #define SPECIFIC_SERVER_PLUG_INIT_PROTO( x ) \
+ sasl_server_plug_init_t x##_server_plug_init
+ 
+ #define SPECIFIC_AUXPROP_PLUG_INIT_PROTO( x ) \
+ sasl_auxprop_init_t x##_auxprop_plug_init
+ 
+ #define SPECIFIC_CANONUSER_PLUG_INIT_PROTO( x ) \
+ sasl_canonuser_init_t x##_canonuser_plug_init
+ 
+ /* Static Compillation Foo */
+ #define SPECIFIC_CLIENT_PLUG_INIT( x, n )\
+ 	{ CLIENT, n, x##_client_plug_init }
+ #define SPECIFIC_SERVER_PLUG_INIT( x, n )\
+ 	{ SERVER, n, (sasl_client_plug_init_t *)x##_server_plug_init }
+ #define SPECIFIC_AUXPROP_PLUG_INIT( x, n )\
+ 	{ AUXPROP, n, (sasl_client_plug_init_t *)x##_auxprop_plug_init }
+ #define SPECIFIC_CANONUSER_PLUG_INIT( x, n )\
+ 	{ CANONUSER, n, (sasl_client_plug_init_t *)x##_canonuser_plug_init }
+ 
+ #ifdef STATIC_ANONYMOUS
+ extern SPECIFIC_SERVER_PLUG_INIT_PROTO( anonymous );
+ extern SPECIFIC_CLIENT_PLUG_INIT_PROTO( anonymous );
+ #endif
+ #ifdef STATIC_CRAMMD5
+ extern SPECIFIC_SERVER_PLUG_INIT_PROTO( crammd5 );
+ extern SPECIFIC_CLIENT_PLUG_INIT_PROTO( crammd5 );
+ #endif
+ #ifdef STATIC_DIGESTMD5
+ extern SPECIFIC_SERVER_PLUG_INIT_PROTO( digestmd5 );
+ extern SPECIFIC_CLIENT_PLUG_INIT_PROTO( digestmd5 );
+ #endif
+ #ifdef STATIC_GSSAPIV2
+ extern SPECIFIC_SERVER_PLUG_INIT_PROTO( gssapiv2 );
+ extern SPECIFIC_CLIENT_PLUG_INIT_PROTO( gssapiv2 );
+ #endif
+ #ifdef STATIC_KERBEROS4
+ extern SPECIFIC_SERVER_PLUG_INIT_PROTO( kerberos4 );
+ extern SPECIFIC_CLIENT_PLUG_INIT_PROTO( kerberos4 );
+ #endif
+ #ifdef STATIC_LOGIN
+ extern SPECIFIC_SERVER_PLUG_INIT_PROTO( login );
+ extern SPECIFIC_CLIENT_PLUG_INIT_PROTO( login );
+ #endif
+ #ifdef STATIC_NTLM
+ extern SPECIFIC_SERVER_PLUG_INIT_PROTO( ntlm );
+ extern SPECIFIC_CLIENT_PLUG_INIT_PROTO( ntlm );
+ #endif
+ #ifdef STATIC_OTP
+ extern SPECIFIC_SERVER_PLUG_INIT_PROTO( otp );
+ extern SPECIFIC_CLIENT_PLUG_INIT_PROTO( otp );
+ #endif
+ #ifdef STATIC_PLAIN
+ extern SPECIFIC_SERVER_PLUG_INIT_PROTO( plain );
+ extern SPECIFIC_CLIENT_PLUG_INIT_PROTO( plain );
+ #endif
+ #ifdef STATIC_SRP
+ extern SPECIFIC_SERVER_PLUG_INIT_PROTO( srp );
+ extern SPECIFIC_CLIENT_PLUG_INIT_PROTO( srp );
+ #endif
+ #ifdef STATIC_SASLDB
+ extern SPECIFIC_AUXPROP_PLUG_INIT_PROTO( sasldb );
+ #endif
+ #ifdef STATIC_SQL
+ extern SPECIFIC_AUXPROP_PLUG_INIT_PROTO( sql );
+ #endif
+ #ifdef STATIC_LDAPDB
+ extern SPECIFIC_AUXPROP_PLUG_INIT_PROTO( ldapdb );
+ #endif
+ 
+ _sasl_plug_rec _sasl_static_plugins[] = {
+ #ifdef STATIC_ANONYMOUS
+ 	SPECIFIC_SERVER_PLUG_INIT( anonymous, "ANONYMOUS" ),
+ 	SPECIFIC_CLIENT_PLUG_INIT( anonymous, "ANONYMOUS" ),
+ #endif
+ #ifdef STATIC_CRAMMD5
+ 	SPECIFIC_SERVER_PLUG_INIT( crammd5, "CRAM-MD5" ),
+ 	SPECIFIC_CLIENT_PLUG_INIT( crammd5, "CRAM-MD5" ),
+ #endif
+ #ifdef STATIC_DIGESTMD5
+ 	SPECIFIC_SERVER_PLUG_INIT( digestmd5, "DIGEST-MD5" ),
+ 	SPECIFIC_CLIENT_PLUG_INIT( digestmd5, "DIGEST-MD5" ),
+ #endif
+ #ifdef STATIC_GSSAPIV2
+ 	SPECIFIC_SERVER_PLUG_INIT( gssapiv2, "GSSAPI" ),
+ 	SPECIFIC_CLIENT_PLUG_INIT( gssapiv2, "GSSAPI" ),
+ #endif
+ #ifdef STATIC_KERBEROS4
+ 	SPECIFIC_SERVER_PLUG_INIT( kerberos4, "KERBEROS_V4" ),
+ 	SPECIFIC_CLIENT_PLUG_INIT( kerberos4, "KERBEROS_V4" ),
+ #endif
+ #ifdef STATIC_LOGIN
+ 	SPECIFIC_SERVER_PLUG_INIT( login, "LOGIN" ),
+ 	SPECIFIC_CLIENT_PLUG_INIT( login, "LOGIN" ),
+ #endif
+ #ifdef STATIC_NTLM
+ 	SPECIFIC_SERVER_PLUG_INIT( ntlm, "NTLM" ),
+ 	SPECIFIC_CLIENT_PLUG_INIT( ntlm, "NTLM" ),
+ #endif
+ #ifdef STATIC_OTP
+ 	SPECIFIC_SERVER_PLUG_INIT( otp, "OTP" ),
+ 	SPECIFIC_CLIENT_PLUG_INIT( otp, "OTP" ),
+ #endif
+ #ifdef STATIC_PLAIN
+ 	SPECIFIC_SERVER_PLUG_INIT( plain, "PLAIN" ),
+ 	SPECIFIC_CLIENT_PLUG_INIT( plain, "PLAIN" ),
+ #endif
+ #ifdef STATIC_SRP
+ 	SPECIFIC_SERVER_PLUG_INIT( srp, "SRP" ),
+ 	SPECIFIC_CLIENT_PLUG_INIT( srp, "SRP" ),
+ #endif
+ #ifdef STATIC_SASLDB
+ 	SPECIFIC_AUXPROP_PLUG_INIT( sasldb, "SASLDB" ),
+ #endif
+ #ifdef STATIC_SQL
+ 	SPECIFIC_AUXPROP_PLUG_INIT( sql, "SQL" ),
+ #endif
+ #ifdef STATIC_LDAPDB
+     SPECIFIC_AUXPROP_PLUG_INIT( ldapdb, "LDAPDB" ),
+ #endif
+ 	{ UNKNOWN, NULL, NULL }
+ };
diff -Narc cyrus-sasl-2.1.22/plugins/Makefile.am /root/cyrus-sasl-2.1.22/plugins/Makefile.am
*** cyrus-sasl-2.1.22/plugins/Makefile.am	Tue Jun 26 12:45:20 2007
--- /root/cyrus-sasl-2.1.22/plugins/Makefile.am	Tue Jun 26 12:38:16 2007
***************
*** 60,65 ****
--- 60,66 ----
  sql_version = 2:22:0
  ldapdb_version = 2:22:0
  srp_version = 2:22:0
+ ldapauxprop_version = 2:10:0
  
  INCLUDES=-I$(top_srcdir)/include -I$(top_srcdir)/lib -I$(top_srcdir)/sasldb -I$(top_builddir)/include
  AM_LDFLAGS = -module -export-dynamic -rpath $(plugindir)
***************
*** 80,86 ****
  sasl_LTLIBRARIES = @SASL_MECHS@
  EXTRA_LTLIBRARIES = libplain.la libanonymous.la libkerberos4.la libcrammd5.la \
  	libgssapiv2.la libdigestmd5.la liblogin.la libsrp.la libotp.la \
! 	libntlm.la libpassdss.la libsasldb.la libsql.la libldapdb.la
  
  libplain_la_SOURCES = plain.c plain_init.c $(common_sources)
  libplain_la_LDFLAGS = -version-info $(plain_version)
--- 81,87 ----
  sasl_LTLIBRARIES = @SASL_MECHS@
  EXTRA_LTLIBRARIES = libplain.la libanonymous.la libkerberos4.la libcrammd5.la \
  	libgssapiv2.la libdigestmd5.la liblogin.la libsrp.la libotp.la \
! 	libntlm.la libpassdss.la libsasldb.la libsql.la libldapdb.la libldapauxprop.la
  
  libplain_la_SOURCES = plain.c plain_init.c $(common_sources)
  libplain_la_LDFLAGS = -version-info $(plain_version)
***************
*** 153,164 ****
  libsql_la_DEPENDENCIES = $(COMPAT_OBJS)
  libsql_la_LIBADD = $(COMPAT_OBJS)
  
  
  # Instructions for making the _init files
  
  init_src=anonymous_init.c crammd5_init.c digestmd5_init.c gssapiv2_init.c \
  kerberos4_init.c login_init.c plain_init.c srp_init.c otp_init.c ntlm_init.c \
! passdss_init.c sasldb_init.c sql_init.c ldapdb_init.c
  
  
  CLEANFILES=$(init_src)
--- 154,170 ----
  libsql_la_DEPENDENCIES = $(COMPAT_OBJS)
  libsql_la_LIBADD = $(COMPAT_OBJS)
  
+ # Auxprop Plugins Ldap 
+ libldapauxprop_la_SOURCES = ldapauxprop.c ldapauxprop_init.c $(common_sources)
+ libldapauxprop_la_LDFLAGS = -lldap -llber -version-info $(ldapauxprop_version)
+ libldapauxprop_la_DEPENDENCIES = $(COMPAT_OBJS)
+ libldapauxprop_la_LIBADD = $(COMPAT_OBJS)
  
  # Instructions for making the _init files
  
  init_src=anonymous_init.c crammd5_init.c digestmd5_init.c gssapiv2_init.c \
  kerberos4_init.c login_init.c plain_init.c srp_init.c otp_init.c ntlm_init.c \
! passdss_init.c sasldb_init.c sql_init.c ldapdb_init.c ldapauxprop_init.c
  
  
  CLEANFILES=$(init_src)
diff -Narc cyrus-sasl-2.1.22/plugins/ldapauxprop.c /root/cyrus-sasl-2.1.22/plugins/ldapauxprop.c
*** cyrus-sasl-2.1.22/plugins/ldapauxprop.c	Thu Jan  1 01:00:00 1970
--- /root/cyrus-sasl-2.1.22/plugins/ldapauxprop.c	Tue Jun 26 12:32:20 2007
***************
*** 0 ****
--- 1,599 ----
+ /*
+ **
+ ** ldap Auxprop plugin
+ **   by Simon Loader
+ **
+ ** $Id$
+ **
+ **  Auxiliary property plugin for Sasl 2.1.0
+ **
+ **  Note: This was tested against openldap-2.0.21 with
+ **     no cyrus-sasl support. If compiled with cyrus-sasl
+ **     it seemed to try and use cyrus-saslv2 as if they are
+ **     version 1. So in theory when openldap becomes saslv2
+ **     compliant all should work.
+ **
+ **   The plugin uses the following options in the
+ ** sasl application config file ( usually in /usr/lib/sasl2 )
+ **
+ **  ldap_user: <username to login as>
+ **  ldap_passwd: <password to use>
+ **  ldap_hostnames: < comma separated host list >
+ **  ldap_filter: < filter to get to users password >
+ **  ldap_basedn: <basedn for the search>
+ **  ldap_verbose:  ( if it exists will print select statement to syslog )
+ **
+ **   The filter used in the option ldap_filter is parsed
+ ** for 2 place holders %u and %r they are replaced with username
+ ** and realm required respectively.
+ **
+ **   %u is the username the user logged in as
+ **   %r is the realm which could be the kerbros realm, the FQDN of the 
+ **     computer the sasl app is on or what ever is after the @ on a username.
+ **   %% is replaced with %
+ **   %<char> is left as is
+ **
+ **  e.g
+ **   ldap_filter: uid=%u
+ **      or feasibly uid=%s,domain=%r,o=SURF
+ **               ldap_basedn: c=UK
+ **
+ **   if something matches the filter the code
+ **  will try and retrieve all properties requested.
+ **  Usually  userPassword and cmusaslsecretMECHNAME where
+ **  MECHNAME is the name of a mechanism.
+ **
+ **  ldap_hostnames: tries to be clever and is can understand url type input.
+ **      e.g. ldap:ldap.surf.org.uk:344,ldaps:secureldap.surf.org.uk
+ **
+ **  put in verbose mode if you want to see what the filter is looking
+ **  for and what it got.
+ **
+ **     
+ */
+ 
+ #include <config.h>
+ 
+ /* checkpw stuff */
+ 
+ #include <stdio.h>
+ #include <assert.h>
+ 
+ #include "sasl.h"
+ #include "saslutil.h"
+ #include "saslplug.h"
+ 
+ #include <ldap.h>
+ #include <lber.h>
+ #include <ctype.h>
+ 
+ #include "plugin_common.h"
+ 
+ typedef struct ldap_settings {
+ 	char *ldap_user;
+ 	char *ldap_passwd;
+ 	char *ldap_hostnames;
+ 	char *ldap_basedn;
+ 	char *ldap_filter;
+ 	int ldap_verbose;
+ 	int have_settings;
+ #ifdef LDAP_OPT_DEREF
+ 	int ldap_alias_deref;
+ #endif
+ } ldap_settings_t;
+ 
+ 
+ /* ldap_host_connect
+ **
+ ** takes: hosts a string of hosts separeted by commas
+ ** e.g
+ **  193.242.127.1,ldaps:banana.com:58,ldap:fish.com
+ */
+ LDAP *ldap_host_connect(char *hosts) {
+ 	const char *rfc_port = "389";
+  	char *cur_ldap_host;
+   char *next_ldap_host;
+   char *host_dup_ptr;
+   char *port;
+   int ssl_mode = 0;
+ #ifdef LDAP_OPT_X_TLS
+ 	int tls_option;
+ #endif
+   LDAP *ld = NULL;
+ 	
+ 	
+   host_dup_ptr = strdup(hosts);
+   next_ldap_host = cur_ldap_host = host_dup_ptr;
+ 	
+ 	
+   while ( cur_ldap_host != NULL ) {
+     ssl_mode = 0;
+     /* find first , and set to null */
+     next_ldap_host = strchr(next_ldap_host,',');
+     if ( next_ldap_host != NULL ) {
+       next_ldap_host[0] = 0x00;
+       /* be nice ignore white space */
+       while (!isalnum(next_ldap_host[0]))
+         next_ldap_host++;
+     }
+     /* ok so we need to know hostname/ip, ldaps or ldap
+     ** and port number if set ???
+     */
+     if ( strstr(cur_ldap_host,"ldaps:") != NULL ) {
+       cur_ldap_host += 6;
+       ssl_mode = 1;
+     }
+     if ( strstr(cur_ldap_host,"ldap:") != NULL ) {
+       cur_ldap_host += 5;
+       ssl_mode = 0;
+     }
+     /* if it doesnt have either we presume ldap */
+     /* now to get the port */
+     if ( (port = strchr(cur_ldap_host,':')) != NULL ) {
+       port[0] = 0x00;
+       port++;
+     } else {
+       port = (char *)rfc_port;
+     }
+ 		
+     ld = ldap_init(cur_ldap_host,atoi(port));
+     if ( ssl_mode ) {
+ #ifdef LDAP_OPT_X_TLS
+       ldap_set_option(ld, LDAP_OPT_X_TLS, (void *)&tls_option);
+ #else
+ 			/* ++++ Print an error saying no TLS support but TLS requested */
+ #endif 
+     }
+     if ( ld != NULL ) {
+ 	    break;
+     }
+     cur_ldap_host = next_ldap_host;
+   }
+ 	
+   free(host_dup_ptr);
+   return(ld);
+ }
+ 
+ 
+ 
+ 
+ /*
+ **  ldap_create_filter
+ **   uses select line and allocate memory to replace
+ **  Parts with the strings provided.
+ **   %% = %
+ **   %u = user
+ **   %r = realm
+ **   %<char> = left as is
+ **  Note: calling function must free memory.
+ ** Better memory copy and proper allocation for muliple %u\%r
+ ** by Birger Toedtmann birger-takatukaland.de
+ **
+ */
+ static char *ldap_create_filter(sasl_server_params_t *sparams,char *select_line,char *user,char *realm)
+ {
+   char *buf,*ptr;
+   char *buf_ptr,*line_ptr;
+   int filtersize = 0;
+ 	
+ 	/* ++++ this could be modulised more */
+   /* calculate memory needed for creating 
+   the complete filter string. */
+   buf = select_line;
+ 
+ 	/* we can use strtok to get all vars */
+ 	while ( (ptr = strchr(buf,'%')) ) {
+ 		buf = ++ptr;
+ 		switch ( buf[0] ) {
+ 				case '%':
+ 					filtersize--;  /* we are actully deleting a character */
+ 					break;
+ 				case 'u':
+ 					filtersize += strlen(user)-2;
+ 					break;
+ 				case 'r':
+ 					filtersize += strlen(realm)-2;
+ 					break;
+ 				default:
+ 					break;
+ 						
+ 		}
+ 	}
+ 
+ /*****************************/
+ 
+ /* alloc mem */
+   filtersize = filtersize+strlen(select_line)+1; /* don't forget the trailing 0x0 */
+ 
+  /* ok, now try to allocate a chunk of that size */
+   if ( (buf = (char *)sparams->utils->malloc(filtersize)) == NULL ) {
+          /* ummm couldnt get the memory something must be up */
+          return NULL;
+   }
+ 
+ /*********************************/
+ 
+ buf_ptr = buf;
+ line_ptr = select_line;
+ 
+ /* replace the strings */
+ 	while ( (ptr = strchr(line_ptr,'%')) ) {
+ 		/* copy what ever we have not done so already */
+ 		memcpy(buf_ptr,line_ptr,ptr - line_ptr); /* -1 we dont want the % */
+ 		buf_ptr += ptr - line_ptr;
+ 		ptr++;
+ 		switch (ptr[0]) {
+ 				case '%':
+ 					buf_ptr[0] = '%';
+ 					buf_ptr++;
+ 					break;
+ 				case 'u':
+ 					memcpy(buf_ptr,user,strlen(user));
+ 					buf_ptr += strlen(user);
+ 					break;
+ 				case 'r':
+ 					memcpy(buf_ptr,realm,strlen(realm));
+ 					buf_ptr += strlen(realm);
+ 					break;
+ 				default:
+ 					buf_ptr[0] = '%';
+ 					buf_ptr[1] = ptr[0];
+ 					buf_ptr += 2;
+ 					break;
+ 		}
+ 		ptr++;
+ 		line_ptr = ptr;
+ 	}
+ 	/* now copy the last bit */
+ 	memcpy(buf_ptr,line_ptr,strlen(line_ptr)+1); /* need the null */
+   	return(buf);
+ 
+ 	
+ }
+ 
+ void ldap_get_settings(const sasl_utils_t *utils,void *glob_context) {
+ 	struct ldap_settings *settings;
+ 	char *verbose_test;
+ 
+ 	settings = (struct ldap_settings *)glob_context;
+ 	if ( settings->have_settings == 0 ) {
+ 		/* do I have to allocate memory for the vars only testing will tell */
+ 		/*( probably )*/
+  	 	utils->getopt(utils->getopt_context,"LDAPAUXPROP","ldap_verbose",(const char **)&verbose_test,NULL);
+  	 	if ( verbose_test != NULL ) {
+  	 	  settings->ldap_verbose = 1;
+  	 	  utils->log(NULL, SASL_LOG_WARN, "ldap auxprop plugin has been initilizsed\n");
+  	 	} else {
+  	 	  settings->ldap_verbose = 0;
+  	 	}
+ 		 
+  	 	utils->getopt(utils->getopt_context,"LDAPAUXPROP","ldap_user",(const char **)&settings->ldap_user,NULL);
+  	 	if ( settings->ldap_user == NULL ) {
+  	 	  /* set it to a blank string */
+  	 	  _plug_strdup(utils,"",&settings->ldap_user,NULL);
+  	 	}
+  	 	utils->getopt(utils->getopt_context,"LDAPAUXPROP", "ldap_passwd", (const char **) &settings->ldap_passwd, NULL);
+  	 	if ( settings->ldap_passwd == NULL ) {
+  	 	  _plug_strdup(utils,"",&settings->ldap_passwd,NULL);
+  	 	}
+  	 	utils->getopt(utils->getopt_context,"LDAPAUXPROP", "ldap_hostnames", (const char **) &settings->ldap_hostnames, NULL);
+  	 	if ( settings->ldap_hostnames == NULL ) {
+  	 	  _plug_strdup(utils,"",&settings->ldap_hostnames,NULL);
+  	 	}
+ 
+ /* this probably came in in openldap v2 so lets not have it unless it exists */
+ #ifdef LDAP_OPT_DEREF
+ 		/* get alias deref type but set to default first */
+ 		settings->ldap_alias_deref = LDAP_DEREF_NEVER;
+  	 	utils->getopt(utils->getopt_context,"LDAPAUXPROP", "ldap_alias_deref", (const char **) &verbose_test, NULL);
+  	 	if ( verbose_test != NULL ) {
+ 			if (*verbose_test == 'n' || *verbose_test =='N') 
+ 				{ settings->ldap_alias_deref=LDAP_DEREF_NEVER; }
+ 			if (*verbose_test == 's' || *verbose_test =='S') 
+ 				{ settings->ldap_alias_deref=LDAP_DEREF_SEARCHING; }
+ 			if (*verbose_test == 'f' || *verbose_test =='F') 
+ 				{ settings->ldap_alias_deref=LDAP_DEREF_FINDING; }
+ 			if (*verbose_test == 'a' || *verbose_test =='A') 
+ 				{ settings->ldap_alias_deref=LDAP_DEREF_ALWAYS; }
+  	 	}
+ #endif /* LDAP_OPT_DEREF */
+ 
+  	 	utils->getopt(utils->getopt_context,"LDAPAUXPROP", "ldap_filter", (const char **) &settings->ldap_filter, NULL);
+  	 	if ( settings->ldap_filter == NULL ) {
+  	 	  _plug_strdup(utils,"",&settings->ldap_filter,NULL);
+  	 	}
+  	 	utils->getopt(utils->getopt_context,"LDAPAUXPROP", "ldap_basedn", (const char **) &settings->ldap_basedn, NULL);
+  	 	if ( settings->ldap_basedn == NULL ) {
+  	 	  _plug_strdup(utils,"",&settings->ldap_basedn,NULL);
+  	 	}
+ 		settings->have_settings = 1;
+ 	}
+ }
+ 
+ 
+ /* returns the realm we should pretend to be in */
+ static int parseuser(const sasl_utils_t *utils,
+                      char **user, char **realm, const char *user_realm, 
+                      const char *serverFQDN, const char *input)
+ {
+ 	int ret;
+ 	char *r;
+ 	
+ 	if(!user || !serverFQDN) {
+ 		PARAMERROR( utils );
+ 		return SASL_BADPARAM;
+ 	}
+ 	
+ 	r = strchr(input, '@');
+ 	if (!r) {
+ 		/* hmmm, the user didn't specify a realm */
+ 		if(user_realm && user_realm[0]) {
+ 			ret = _plug_strdup(utils, user_realm, realm, NULL);
+ 		} else {
+ 			/* Default to serverFQDN */
+ 			ret = _plug_strdup(utils, serverFQDN, realm, NULL);
+ 		}
+ 		
+ 		if (ret == SASL_OK) {
+ 			ret = _plug_strdup(utils, input, user, NULL);
+ 		}
+ 	} else {
+ 		r++;
+ 		ret = _plug_strdup(utils, r, realm, NULL);
+ 		*--r = '\0';
+ 		*user = utils->malloc(r - input + 1);
+ 		if (*user) {
+ 			strncpy(*user, input, r - input +1);
+ 		} else {
+ 			MEMERROR( utils );
+ 			ret = SASL_NOMEM;
+ 		}
+ 		*r = '@';
+ 	}
+ 	
+ 	return ret;
+ }
+ 
+ 
+ /* from Scot W. Hetzel <hetzels at westbend.net>
+ **   this is for comptabilty with openldap 1 and 2
+ */
+ #ifdef LDAP_VENDOR_VERSION
+ #define SASL_ldap_search_ext_s(ld, base, scope, filter, attrs, attrsonly, serverctrls, clientctrls, timeout, sizelimit, res) \
+        ldap_search_ext_s(ld, base, scope, filter, attrs, attrsonly, serverctrls, clientctrls, timeout, sizelimit, res)
+ #define SASL_ldap_memfree(dn) ldap_memfree(dn)
+ #else
+ #define SASL_ldap_search_ext_s(ld, base, scope, filter, attrs, attrsonly, serverctrls, clientctrls, timeout, sizelimit, res) \
+         ldap_search_st(ld, base, scope, filter, attrs, attrsonly, timeout, res)
+ #define SASL_ldap_memfree(dn) sparams->utils->free(dn)
+ #endif
+ 
+ 
+ 
+ static void ldap_auxprop_lookup(void *glob_context,
+ 																sasl_server_params_t *sparams,
+ 																unsigned flags,
+ 																const char *user,
+ 																unsigned ulen) 
+ {
+ 	char *userid = NULL;
+ 	/* realm could be used for something clever */
+ 	char *realm = NULL;
+ 	const char *user_realm = NULL;
+ 	const struct propval *to_fetch, *cur;
+ 	char value[8192];
+ 	size_t value_len = 0;
+ 	
+ 	char *user_buf;
+ 	char *cur_prop;
+ 	
+ 	char *filter = NULL;
+ 	struct ldap_settings *settings;
+   LDAP *ld = NULL;
+ 	int attrs_index = 0;
+ 	LDAPMessage	*result,*entry;
+ 	BerElement *berptr;
+ 	struct berval **berval = NULL;
+ 	char *attrs[100];
+ 	
+ 	if(!sparams || !user) return;
+ 	
+ 	/* setup the settings */
+ 	settings = (struct ldap_settings *)glob_context;
+ 	ldap_get_settings(sparams->utils,glob_context);
+ 	/*  MOVE BELOW TO PARSEUSER function */
+ 	
+ 	user_buf = sparams->utils->malloc(ulen + 1);
+ 	if(!user_buf)
+ 		goto done;
+ 	
+ 	memcpy(user_buf, user, ulen);
+ 	user_buf[ulen] = '\0';
+ 	
+ 	if(sparams->user_realm) {
+ 		user_realm = sparams->user_realm;
+ 	} else {
+ 		user_realm = sparams->serverFQDN;
+ 	}
+ 	
+ 	if ( parseuser(sparams->utils, &userid, &realm, user_realm,
+ 								 sparams->serverFQDN, user_buf) != SASL_OK ) goto done;
+ 	
+ 	/*************************************/
+ 	
+ 	/* find out what we need to get */
+ 	/* this corrupts const char *user */
+ 	to_fetch = sparams->utils->prop_get(sparams->propctx);
+ 	if(!to_fetch) goto done;
+ 	
+ 	/* now loop around hostnames till we get a connection 
+ 	** it should probably save the connection but for 
+ 	** now we will just disconnect eveyrtime
+ 	*/
+ 	
+ 	/***************************************/
+ 	/* Make a connection to an ldap server */
+ 	if ( settings->ldap_verbose )
+ 	  sparams->utils->log(NULL, SASL_LOG_WARN,
+ 												"ldap plugin trying hostnames %s\n",settings->ldap_hostnames);
+ 	if ( (ld = ldap_host_connect(settings->ldap_hostnames)) == NULL ) {
+ 		sparams->utils->log(NULL, SASL_LOG_WARN, "ldap plugin failed to connect to a server\n");
+ 		goto done;
+ 	}
+ #ifdef LDAP_OPT_DEREF
+ 	/* Ok lets set the dereferensing alias mode */
+ 	if (ldap_set_option(ld, LDAP_OPT_DEREF, (void *) &settings->ldap_alias_deref) != LDAP_OPT_SUCCESS) {
+ 		sparams->utils->log(NULL, SASL_LOG_WARN, "ldap plugin failed to set dereferensing aliases mode\n");
+ 		goto done;
+ 	}
+ #endif /* LDAP_OPT_DEREF */
+ 	if ( settings->ldap_verbose )
+ 	  sparams->utils->log(NULL, SASL_LOG_WARN,
+ 												"ldap plugin trying binding as %s with %s\n",settings->ldap_user,settings->ldap_passwd);
+ 	/* bind as user given */
+   if (ldap_simple_bind_s(ld,settings->ldap_user,settings->ldap_passwd) != LDAP_SUCCESS) {
+ 		sparams->utils->log(NULL, SASL_LOG_WARN, "ldap plugin failed to bind as user given\n");
+     goto done;
+   }
+   /***************************************/
+   /* create a list of attributes we want */	
+ 	for(cur = to_fetch; cur->name; cur++) {
+ 		/* Only look up properties that apply to this lookup! */
+ #ifdef SASL_AUXPROP_AUTHZID
+ 		if(cur->name[0] == '*' && (flags & SASL_AUXPROP_AUTHZID)) continue;
+ 		if(!(flags & SASL_AUXPROP_AUTHZID) && cur->name[0] != '*') {
+ 			continue;
+ 		}
+ #endif
+ 		/* If it's there already, we want to see if it needs to be
+ 		 * overridden */
+ 		if(cur->values && !(flags & SASL_AUXPROP_OVERRIDE))
+ 	    continue;
+ 		else if(cur->values)
+ 	    sparams->utils->prop_erase(sparams->propctx, cur->name);
+     /* add it to the list */
+ 		/* +++++++ need to allocate some memory for all this */
+ 		if ( settings->ldap_verbose )
+ 			sparams->utils->log(NULL, SASL_LOG_WARN, "looking for value %s\n",cur->name);
+ #ifdef SASL_AUXPROP_AUTHZID
+ 		if(!(flags & SASL_AUXPROP_AUTHZID) && cur->name[0] == '*' ) {
+ 			attrs[attrs_index++] = (char *)cur->name+1;
+ 		} else {
+ #endif
+ 			attrs[attrs_index++] = (char *)cur->name;
+ #ifdef SASL_AUXPROP_AUTHZID
+ 		}
+ #endif
+ 		if ( attrs_index > 99 ) {
+ 		  sparams->utils->log(NULL, SASL_LOG_WARN, "ldap plugin more than 100 properties\n");
+ 			break;
+ 		}
+ 	}
+ 	/* make the last bit null to signify end as not all 
+ 	** unices null memory
+ 	** bug found by 
+   ** by Birger Toedtmann birger-takatukaland.de
+ 	*/
+ 	attrs[attrs_index++] = NULL;
+ 	/*****************************************/
+ 	/* create a filter to find the user info */
+ 	filter = ldap_create_filter(sparams,settings->ldap_filter,userid,realm);
+ 	if ( settings->ldap_verbose )
+ 		sparams->utils->log(NULL, SASL_LOG_WARN,
+ 												"ldap plugin doing filter %s\n",filter);
+ 	/* run this filter and get the properties */
+ 	/* Now do the search */
+   if (SASL_ldap_search_ext_s(ld,settings->ldap_basedn, LDAP_SCOPE_SUBTREE, filter,
+ 														 attrs, 0, NULL, NULL, LDAP_NO_LIMIT, 1, &result) !=
+ 			LDAP_SUCCESS) {
+ 		sparams->utils->free(filter);
+ 		goto done;
+ 	}
+ 	
+ 	/* Get the property name and value for everything */
+ 	/* Now get the entry from the search results */
+ 	if ( (entry = ldap_first_entry(ld, result)) ==NULL) {
+ 		sparams->utils->free(filter);
+ 		SASL_ldap_memfree(result);
+ 		goto done;
+ 	}
+ 	
+ 	/* free filter */
+ 	sparams->utils->free(filter);
+ 	
+ 	/* now get the results set value and value_len */
+ 	cur_prop = ldap_first_attribute(ld, entry,&berptr);
+ 	
+ 	while ( cur_prop != NULL ) {
+ 		berval = ldap_get_values_len(ld,entry,cur_prop);
+ 		strncpy(value,berval[0]->bv_val,8190);
+ 		value_len = berval[0]->bv_len;
+ 		
+ 		if ( settings->ldap_verbose )
+ 			sparams->utils->log(NULL, SASL_LOG_WARN,
+ 													"ldap plugin setting property %s to value %s\n",cur_prop,value);
+ 		sparams->utils->prop_set(sparams->propctx, cur_prop,
+ 														 value, value_len);
+ 		ldap_value_free_len(berval);
+ 		cur_prop = ldap_next_attribute(ld, entry, berptr);
+ 	}
+ 	ber_memfree(berptr);
+ 	
+  done:
+   if (ld) ldap_unbind(ld);
+ 	if (userid) sparams->utils->free(userid);
+ 	if (realm)  sparams->utils->free(realm);
+ 	if (user_buf) sparams->utils->free(user_buf);
+ }
+ 
+ static void ldap_auxprop_free(void *glob_context, const sasl_utils_t *utils) {
+   struct ldap_settings *settings;
+   settings = (struct ldap_settings *)glob_context;
+ 	utils->log(NULL, SASL_LOG_DEBUG, "ldap freeing meme\n");
+   utils->free(settings->ldap_user);
+   utils->free(settings->ldap_passwd);
+   utils->free(settings->ldap_hostnames);
+   utils->free(settings->ldap_filter);
+   utils->free(settings);
+ }
+ 
+ static sasl_auxprop_plug_t ldap_auxprop_plugin = {
+ 	0,           /* Features */
+ 	0,           /* spare */
+ 	NULL,        /* glob_context */
+ 	ldap_auxprop_free,        /* auxprop_free */
+ 	ldap_auxprop_lookup, /* auxprop_lookup */
+ 	NULL,        /* spares */
+ 	NULL
+ };
+ 
+ int ldapauxprop_auxprop_plug_init(const sasl_utils_t *utils,
+ 																	int max_version,
+ 																	int *out_version,
+ 																	sasl_auxprop_plug_t **plug,
+ 																	const char *plugname) 
+ {
+ 	struct ldap_settings *settings;
+ 	if(!out_version || !plug) return SASL_BADPARAM;
+ 	
+ 	/* We only support the "LDAP" plugin */
+ 	if(plugname && strcmp(plugname, "ldapauxprop")) return SASL_NOMECH;
+ 	
+ 	if(max_version < SASL_AUXPROP_PLUG_VERSION) return SASL_BADVERS;
+ 	*out_version = SASL_AUXPROP_PLUG_VERSION;
+ 	
+ 	*plug = &ldap_auxprop_plugin;
+ 	
+ 	/* should I get config values here or not 
+ 	** only testing will tell
+ 	** ok we need to get some options
+ 	**
+ 	*/
+   
+ 	settings = (struct ldap_settings *)utils->malloc(sizeof(struct ldap_settings));
+ 	ldap_auxprop_plugin.glob_context = settings;
+ 	settings->have_settings = 0;
+ 	
+ 
+ 	return SASL_OK;
+ }
diff -Narc cyrus-sasl-2.1.22/plugins/makeinit.sh /root/cyrus-sasl-2.1.22/plugins/makeinit.sh
*** cyrus-sasl-2.1.22/plugins/makeinit.sh	Wed Feb 16 21:52:12 2005
--- /root/cyrus-sasl-2.1.22/plugins/makeinit.sh	Tue Jun 26 12:38:58 2007
***************
*** 45,51 ****
  " > ${mech}_init.c
  done
  
! for mech in sasldb sql ldapdb; do
  
  echo "
  #include <config.h>
--- 45,51 ----
  " > ${mech}_init.c
  done
  
! for mech in sasldb sql ldapdb ldapauxprop; do
  
  echo "
  #include <config.h>
