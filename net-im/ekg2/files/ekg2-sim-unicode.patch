Index: plugins/sim/simlite.c
===================================================================
--- plugins/sim/simlite.c	(revision 4593)
+++ plugins/sim/simlite.c	(working copy)
@@ -23,6 +23,8 @@
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include "ekg2-config.h"
+
 #define _XOPEN_SOURCE 600
 #include <openssl/bio.h>
 #include <openssl/evp.h>
@@ -40,6 +42,7 @@
 #include "simlite.h"
 #include <ekg/debug.h>
 #include <ekg/xmalloc.h>
+#include <ekg/stuff.h>
 
 char *sim_key_path = NULL;
 int sim_errno = 0;
@@ -379,6 +382,103 @@
 	return res;
 }
 
+
+void *conv_in   = (void*) -1;
+void *conv_out  = (void*) -1;
+
+static const unsigned char cp_to_iso_table[] = {
+	 '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',
+	 '?',  '?', 0xa9,  '?', 0xa6, 0xab, 0xae, 0xac,
+	 '?',  '?',  '?',  '?',  '?',  '?',  '?',  '?',
+	 '?',  '?', 0xb9,  '?', 0xb6, 0xbb, 0xbe, 0xbc,
+	0xa0, 0xb7, 0xa2, 0xa3, 0xa4, 0xa1,  '?', 0xa7,
+	0xa8,  '?', 0xaa,  '?',  '?', 0xad,  '?', 0xaf,
+	0xb0,  '?', 0xb2, 0xb3, 0xb4,  '?',  '?',  '?',
+	0xb8, 0xb1, 0xba,  '?', 0xa5, 0xbd, 0xb5, 0xbf,
+};
+
+#if (USE_UNICODE || HAVE_GTK)
+static const unsigned short table_cp1250[] = {
+        0x20ac, 0x0000, 0x201a, 0x0000, 0x201e, 0x2026, 0x2020, 0x2021,
+        0x0000, 0x2030, 0x0160, 0x2039, 0x015a, 0x0164, 0x017d, 0x0179,
+        0x0000, 0x2018, 0x2019, 0x201c, 0x201d, 0x2022, 0x2013, 0x2014,
+        0x0000, 0x2122, 0x0161, 0x203a, 0x015b, 0x0165, 0x017e, 0x017a,
+        0x00a0, 0x02c7, 0x02d8, 0x0141, 0x00a4, 0x0104, 0x00a6, 0x00a7,
+        0x00a8, 0x00a9, 0x015e, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x017b,
+        0x00b0, 0x00b1, 0x02db, 0x0142, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
+        0x00b8, 0x0105, 0x015f, 0x00bb, 0x013d, 0x02dd, 0x013e, 0x017c,
+        0x0154, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0139, 0x0106, 0x00c7,
+        0x010c, 0x00c9, 0x0118, 0x00cb, 0x011a, 0x00cd, 0x00ce, 0x010e,
+        0x0110, 0x0143, 0x0147, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x00d7,
+        0x0158, 0x016e, 0x00da, 0x0170, 0x00dc, 0x00dd, 0x0162, 0x00df,
+        0x0155, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x013a, 0x0107, 0x00e7,
+        0x010d, 0x00e9, 0x0119, 0x00eb, 0x011b, 0x00ed, 0x00ee, 0x010f,
+        0x0111, 0x0144, 0x0148, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x00f7,
+        0x0159, 0x016f, 0x00fa, 0x0171, 0x00fc, 0x00fd, 0x0163, 0x02d9,
+};
+#endif
+
+static unsigned char *gg_cp_to_iso(unsigned char *buf) {
+	unsigned char *tmp = buf;
+
+	if (!buf)
+		return NULL;
+
+	while (*buf) {
+		if (*buf >= 0x80 && *buf < 0xC0)
+			*buf = cp_to_iso_table[*buf - 0x80];
+		
+		buf++;
+	}
+	return tmp;
+}
+
+char *gg_cp_to_locale(char *b) {
+	unsigned char *buf = (unsigned char *) b;
+
+	if (!buf)
+		return NULL;
+#if (USE_UNICODE || HAVE_GTK)
+	if (config_use_unicode) { /* shitty way with string_t */
+	/* wchar */
+		int len = xstrlen(b);
+		wchar_t *tmp = xmalloc((len+1)*sizeof(wchar_t));	/* optimize len ? DELAYED */
+	/* char */
+		char *newbuf;
+		int n, i;
+		
+		for (i=0; i < len; i++) {
+			if (buf[i] < 0x80)	      tmp[i] = buf[i];						/* ASCII */
+			else if (buf[i] == 0x81 || buf[i] == 0x83 || buf[i] == 0x88 || buf[i] == 0x90 || buf[i] == 0x98) /* undefined chars in cp1250 */
+							tmp[i] = '?';
+			else			    tmp[i] = table_cp1250[buf[i]-0x80];			     /* unicode <==> cp1250 */
+		}
+		
+		n       = wcstombs(NULL, tmp, 0)+1;
+		newbuf  = xmalloc(n+1);
+		
+		if ((wcstombs(newbuf, tmp, n)) == -1) {
+			debug("[%s:%d] wcstombs() failed with: %s (%d)\n", errno, strerror(errno));
+			xfree(newbuf);
+			xfree(tmp);
+			return b;	       /* return `cp` seq ? */
+		}
+		xfree(tmp);
+		xfree(buf);		     /* XXX, need testing */
+		return newbuf;
+	} else
+#endif  
+	if (conv_in != (void*) -1) {
+		char *out = ekg_convert_string_p(b, conv_in);
+		if (out)
+			xfree(b);
+		else    
+			out = b;
+		return out;
+	} else  
+		return (char *) gg_cp_to_iso(buf);
+}
+
 /*
  * sim_message_decrypt()
  *
@@ -398,6 +498,7 @@
 	BIO *mbio = NULL, *cbio = NULL, *bbio = NULL;
 	RSA *private = NULL;
 	unsigned char *buf = NULL, *res = NULL, *data;
+	char *buf2;
 	int len, cx;
 
 	/* je¶li wiadomo¶æ jest krótsza ni¿ najkrótsza zaszyfrowana,
@@ -484,15 +585,13 @@
 	memcpy(res, data + sizeof(head), len);
 	res[len] = 0;
 
-	for(cx = 0; cx < len; cx++)
-	    switch(res[cx]) {
-		case 156: res[cx] = '¶'; break;
-		case 185: res[cx] = '±'; break;
-		case 159: res[cx] = '¼'; break;
-		case 140: res[cx] = '¦'; break;
-		case 165: res[cx] = '¡'; break;
-		case 143: res[cx] = '¬'; break;
-	    }
+	debug("pre: %s\n", res);
+	buf2 = gg_cp_to_locale(xstrdup((const char *)res));
+	debug("post: %s\n", buf2);
+	xfree(res);
+	res = buf2;
+	buf2 = NULL;
+
 cleanup:
 	if (cbio)
 		BIO_free(cbio);
