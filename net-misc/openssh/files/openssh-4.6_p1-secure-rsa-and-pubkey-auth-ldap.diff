diff -Narc openssh-4.6p1.orig/auth-rsa.c openssh-4.6p1/auth-rsa.c
*** openssh-4.6p1.orig/auth-rsa.c	Wed Aug  8 10:55:06 2007
--- openssh-4.6p1/auth-rsa.c	Wed Aug  8 10:59:05 2007
***************
*** 180,188 ****
  	unsigned int i = 0;
  #endif
  
- 	/* Temporarily use the user's uid. */
- 	temporarily_use_uid(pw);
- 
  #ifdef WITH_LDAP_PUBKEY
  	/* here is the job */
  	key = key_new(KEY_RSA1);
--- 180,185 ----
***************
*** 244,253 ****
  			/* break out, this key is allowed */
  			allowed = 1;
  
- 			/* add the return stuff etc... */
- 			/* Restore the privileged uid. */
- 			restore_uid();
- 
  			/* return key if allowed */
  			if (allowed && rkey != NULL)
  			    *rkey = key;
--- 241,246 ----
***************
*** 271,286 ****
  
  	/* Fail quietly if file does not exist */
  	if (stat(file, &st) < 0) {
- 		/* Restore the privileged uid. */
- 		restore_uid();
  		xfree(file);
  		return (0);
  	}
  	/* Open the file containing the authorized keys. */
  	f = fopen(file, "r");
  	if (!f) {
- 		/* Restore the privileged uid. */
- 		restore_uid();
  		xfree(file);
  		return (0);
  	}
--- 264,275 ----
***************
*** 289,295 ****
  		xfree(file);
  		fclose(f);
  		logit("Authentication refused: %s", line);
- 		restore_uid();
  		return (0);
  	}
  
--- 278,283 ----
***************
*** 306,311 ****
--- 294,300 ----
  	while (read_keyfile_line(f, file, line, sizeof(line), &linenum) != -1) {
  		char *cp;
  		char *key_options;
+ 		char *user;
  		int keybits;
  
  		/* Skip leading whitespace, empty and comment lines. */
***************
*** 344,349 ****
--- 333,346 ----
  		if (BN_cmp(key->rsa->n, client_n) != 0)
  			continue;
  
+ 		/* Now get the comment field. This is the username. */
+ 		/* Skip spaces */
+ 		for (; *cp == ' ' || *cp == '\t'; cp++)
+ 			;
+ 		for (user=cp; *cp != ' ' && *cp != '\t' && *cp != '\n'; cp++)
+ 			;
+ 		*cp = '\0';
+ 
  		/* check the real bits  */
  		keybits = BN_num_bits(key->rsa->n);
  		if (keybits < 0 || bits != (u_int)keybits)
***************
*** 359,372 ****
  		if (!auth_parse_options(pw, key_options, file, linenum))
  			continue;
  
  		/* break out, this key is allowed */
  		allowed = 1;
  		break;
  	}
  
- 	/* Restore the privileged uid. */
- 	restore_uid();
- 
  	/* Close the file. */
  	xfree(file);
  	fclose(f);
--- 356,379 ----
  		if (!auth_parse_options(pw, key_options, file, linenum))
  			continue;
  
+ 		if (*options.authorized_keys_file=='/') {
+ 			/* Check the user */
+ 			if(strlen(user)) {
+ 				if(strncmp(user, pw->pw_name, strlen(pw->pw_name)+1)) {
+ 					logit("RSA warning: User %s tried to use public key of user %s!", pw->pw_name, user);
+ 					break;
+ 				}
+ 			} else {
+ 				logit("RSA warning: no username associated with key - refusing connection.");
+ 				break;
+ 			}
+ 		}
+ 
  		/* break out, this key is allowed */
  		allowed = 1;
  		break;
  	}
  
  	/* Close the file. */
  	xfree(file);
  	fclose(f);
diff -Narc openssh-4.6p1.orig/auth2-pubkey.c openssh-4.6p1/auth2-pubkey.c
*** openssh-4.6p1.orig/auth2-pubkey.c	Wed Aug  8 10:55:06 2007
--- openssh-4.6p1/auth2-pubkey.c	Wed Aug  8 11:00:58 2007
***************
*** 179,185 ****
  	return authenticated;
  }
  
! /* return 1 if user allows given key */
  static int
  user_key_allowed2(struct passwd *pw, Key *key, char *file)
  {
--- 179,185 ----
  	return authenticated;
  }
  
! /* return 1 if the admin allows given key */
  static int
  user_key_allowed2(struct passwd *pw, Key *key, char *file)
  {
***************
*** 195,203 ****
  	unsigned int i = 0;
  #endif
  
- 	/* Temporarily use the user's uid. */
- 	temporarily_use_uid(pw);
- 
  #ifdef WITH_LDAP_PUBKEY
   	found_key = 0;
   	/* allocate a new key type */
--- 195,200 ----
***************
*** 249,255 ****
  			    /* restoring memory */
  			    ldap_keys_free(k);
  			    xfree(fp);
- 			    restore_uid();
  			    key_free(found);
  			    return found_key;
  			    break;
--- 246,251 ----
***************
*** 267,281 ****
  
  	/* Fail quietly if file does not exist */
  	if (stat(file, &st) < 0) {
- 		/* Restore the privileged uid. */
- 		restore_uid();
  		return 0;
  	}
  	/* Open the file containing the authorized keys. */
  	f = fopen(file, "r");
  	if (!f) {
- 		/* Restore the privileged uid. */
- 		restore_uid();
  		return 0;
  	}
  	if (options.strict_modes &&
--- 263,273 ----
***************
*** 291,296 ****
--- 283,289 ----
  
  	while (read_keyfile_line(f, file, line, sizeof(line), &linenum) != -1) {
  		char *cp, *key_options = NULL;
+ 		char *user;
  
  		/* Skip leading whitespace, empty and comment lines. */
  		for (cp = line; *cp == ' ' || *cp == '\t'; cp++)
***************
*** 320,325 ****
--- 313,336 ----
  		}
  		if (key_equal(found, key) &&
  		    auth_parse_options(pw, key_options, file, linenum) == 1) {
+ 			if (*options.authorized_keys_file=='/') {
+ 				/* Check the user. */
+ 				for(; *cp == ' ' || *cp == '\t'; cp++)
+ 					;
+ 				for(user=cp; *cp != ' ' && *cp != '\t' && *cp != '\n'; cp++)
+ 					;
+ 				*cp = '\0';
+ 				if(strlen(user)) {
+ 					if(strncmp(user, pw->pw_name, strlen(pw->pw_name)+1)) {
+ 						logit("pkauth warning: User %s tried to use public key of user %s!", pw->pw_name, user);
+ 						break;
+ 					}
+ 				} else {
+ 					logit("pkauth warning: no username associated with key - refusing connection.");
+ 					break;
+ 				}
+ 			}
+ 
  			found_key = 1;
  			debug("matching key found: file %s, line %lu",
  			    file, linenum);
***************
*** 330,336 ****
  			break;
  		}
  	}
- 	restore_uid();
  	fclose(f);
  	key_free(found);
  	if (!found_key)
--- 341,346 ----
