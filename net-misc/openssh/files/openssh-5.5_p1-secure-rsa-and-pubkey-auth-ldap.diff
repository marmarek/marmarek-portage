diff -Naru openssh-5.5p1.orig/auth-rsa.c openssh-5.5p1/auth-rsa.c
--- openssh-5.5p1.orig/auth-rsa.c	2010-05-30 02:37:24.512746473 +0200
+++ openssh-5.5p1/auth-rsa.c	2010-05-30 02:38:22.787789569 +0200
@@ -182,9 +182,6 @@
 	unsigned int i = 0;
 #endif
 
-	/* Temporarily use the user's uid. */
-	temporarily_use_uid(pw);
-
 #ifdef WITH_LDAP_PUBKEY
 	/* here is the job */
 	key = key_new(KEY_RSA1);
@@ -246,10 +243,6 @@
 			/* break out, this key is allowed */
 			allowed = 1;
 
-			/* add the return stuff etc... */
-			/* Restore the privileged uid. */
-			restore_uid();
-
 			/* return key if allowed */
 			if (allowed && rkey != NULL)
 			    *rkey = key;
@@ -273,7 +266,6 @@
 	f = auth_openkeyfile(file, pw, options.strict_modes);
 	if (!f) {
 		xfree(file);
-		restore_uid();
 		return (0);
 	}
 
@@ -290,6 +282,7 @@
 	while (read_keyfile_line(f, file, line, sizeof(line), &linenum) != -1) {
 		char *cp;
 		char *key_options;
+		char *user;
 		int keybits;
 
 		/* Skip leading whitespace, empty and comment lines. */
@@ -328,6 +321,14 @@
 		if (BN_cmp(key->rsa->n, client_n) != 0)
 			continue;
 
+		/* Now get the comment field. This is the username. */
+		/* Skip spaces */
+		for (; *cp == ' ' || *cp == '\t'; cp++)
+			;
+		for (user=cp; *cp != ' ' && *cp != '\t' && *cp != '\n'; cp++)
+			;
+		*cp = '\0';
+
 		/* check the real bits  */
 		keybits = BN_num_bits(key->rsa->n);
 		if (keybits < 0 || bits != (u_int)keybits)
@@ -343,14 +344,24 @@
 		if (!auth_parse_options(pw, key_options, file, linenum))
 			continue;
 
+		if (*options.authorized_keys_file=='/') {
+			/* Check the user */
+			if(strlen(user)) {
+				if(strncmp(user, pw->pw_name, strlen(pw->pw_name)+1)) {
+					logit("RSA warning: User %s tried to use public key of user %s!", pw->pw_name, user);
+					break;
+				}
+			} else {
+				logit("RSA warning: no username associated with key - refusing connection.");
+				break;
+			}
+		}
+
 		/* break out, this key is allowed */
 		allowed = 1;
 		break;
 	}
 
-	/* Restore the privileged uid. */
-	restore_uid();
-
 	/* Close the file. */
 	xfree(file);
 	fclose(f);
diff -Naru openssh-5.5p1.orig/auth2-pubkey.c openssh-5.5p1/auth2-pubkey.c
--- openssh-5.5p1.orig/auth2-pubkey.c	2010-05-30 02:37:24.504788726 +0200
+++ openssh-5.5p1/auth2-pubkey.c	2010-05-30 02:42:24.448240495 +0200
@@ -180,7 +180,7 @@
 	return authenticated;
 }
 
-/* return 1 if user allows given key */
+/* return 1 if the admin allows given key */
 static int
 user_key_allowed2(struct passwd *pw, Key *key, char *file)
 {
@@ -196,9 +196,6 @@
 	unsigned int i = 0;
 #endif
 
-	/* Temporarily use the user's uid. */
-	temporarily_use_uid(pw);
-
 #ifdef WITH_LDAP_PUBKEY
 	found_key = 0;
 	/* allocate a new key type */
@@ -250,7 +247,6 @@
 			    /* restoring memory */
 			    ldap_keys_free(k);
 			    xfree(fp);
-			    restore_uid();
 			    key_free(found);
 			    return found_key;
 			    break;
@@ -268,7 +264,6 @@
 	f = auth_openkeyfile(file, pw, options.strict_modes);
 
 	if (!f) {
-		restore_uid();
 		return 0;
 	}
 
@@ -277,6 +272,7 @@
 
 	while (read_keyfile_line(f, file, line, sizeof(line), &linenum) != -1) {
 		char *cp, *key_options = NULL;
+		char *user;
 
 		auth_clear_options();
 
@@ -336,6 +332,24 @@
 			found_key = 1;
 			break;
 		} else if (!key_is_cert_authority && key_equal(found, key)) {
+			if (*options.authorized_keys_file=='/') {
+				/* Check the user. */
+				for(; *cp == ' ' || *cp == '\t'; cp++)
+					;
+				for(user=cp; *cp != ' ' && *cp != '\t' && *cp != '\n'; cp++)
+					;
+				*cp = '\0';
+				if(strlen(user)) {
+					if(strncmp(user, pw->pw_name, strlen(pw->pw_name)+1)) {
+						logit("pkauth warning: User %s tried to use public key of user %s!", pw->pw_name, user);
+						break;
+					}
+				} else {
+					logit("pkauth warning: no username associated with key - refusing connection.");
+					break;
+				}
+			}
+
 			found_key = 1;
 			debug("matching key found: file %s, line %lu",
 			    file, linenum);
@@ -346,7 +360,6 @@
 			break;
 		}
 	}
-	restore_uid();
 	fclose(f);
 	key_free(found);
 	if (!found_key)
